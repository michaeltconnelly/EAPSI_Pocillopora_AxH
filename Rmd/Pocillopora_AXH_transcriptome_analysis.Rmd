---
title: "Pocillopora_AXH_transcriptome_analysis"
author: "Mike Connelly"
date: "7/21/2020"
output: 
  html_document:
      code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
knitr::opts_knit$set(root.dir = "~/computing/projects/EAPSI_Pocillopora_AxH/")
options(stringsAsFactors = FALSE)
```
## Setup packages and working directories
Include all packages needed for the entire transcriptome analysis and downstream visualizations
```{r packages, message=FALSE, include=FALSE}
#essential analysis packages
library("tidyverse")
library("DESeq2")
library("apeglm")
library("variancePartition")
library("doParallel")
library("limma")
library("adegenet")
library("WGCNA")
library("dynamicTreeCut")
library("flashClust")
# GO/KOG enrichment packages and other functions
library("KOGMWU")
source("./R/GO_MWU/gomwu.functions.R")
source("./R/AXH_functions.R")
# Data visualization packages
library("pheatmap")
library("ComplexHeatmap")
library("VennDiagram")
library("eulerr")
library("cowplot")
library("patchwork")
library("gridExtra")
library("ggthemes")
library("ggpubr")
library("ggrepel")
library("ggnewscale")
library("RColorBrewer")
library("wesanderson")
library("circlize")
library("stringr")
library("extrafont")
library("extrafontdb")
```
```{r colors}
# Set overall colors and shapes for ggplot2
# colors for variance partition violin plot
varcolors <- c(wes_palette(n=3, name="Zissou1"), "grey85")
# colors for experimental treatments
condcolors_AxH <- c("blue", "darkorange", "cyan", "gold")
condcolors_heat <- c(condcolors_AxH[1:2])
condcolors_anti <- c(condcolors_AxH[1], condcolors_AxH[3])
condcolors_anti.heat <- c(condcolors_AxH[1], condcolors_AxH[4])
condfillcolors_AxH <- c("#99CCFF", "#FFCC99", "#99FFFF", "#FFFF66") # fill colors for some figures
# shapes and colors for colonies
colshapes <- c(21, 24, 22, 23)
colcolors <- c("olivedrab3", "springgreen", "deepskyblue", "skyblue")
# null colors for presentation figures
condcolors_null <- c(rep("black", 4))
colshapes_null <- c(rep(20, 8))
# differential gene expression volcano plot point colors
DEGcolors <- c("red", "blue", "dark grey")
```
```{r heatmap_colors}
# Create colony and condition annotation colors list
anno_colors <- list(
  Colony = c(HW1=colcolors[1], HW2=colcolors[2], WT1=colcolors[3], WT2=colcolors[4]),
  Treatment = c(control=condcolors_AxH[1],  Heat=condcolors_AxH[2], Antibiotics=condcolors_AxH[3], Antibiotics.Heat=condcolors_AxH[4]),
  DEG = c(Upregulated="red", Downregulated="blue"))
# Create sample heatmap cell color
colonyclustercol <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
# Create gene expression cell color
paletteLength <- 100
# Red --> Blue gradient
geneexpcolors <- colorRampPalette(rev(c("red", "yellow", "white", "cyan", "blue")))(paletteLength)
# Orange --> Cyan gradient
geneexpcolors1 <- colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(paletteLength)
# Red --> Blue dark gradient
geneexpcolors2 <- colorRampPalette(rev(c("red", "yellow", "grey10", "cyan", "blue")))(paletteLength)
# Color bars to preview
#color.bar(geneexpcolors, -1, 1)
#color.bar(geneexpcolors1, -1, 1)
#color.bar(geneexpcolors2, -1, 1)
```
```{r theme}
# Create ggplot2 theme for Molecular Ecology submission
theme_mec <- function(base_size = 10, base_family = "Arial") {
(theme_foundation(base_size=base_size, base_family=base_family)
 + theme(
   plot.background = element_rect(colour = NA),
   panel.background = element_blank(),
   panel.grid.major = element_blank(), 
   panel.grid.minor = element_blank(), 
   panel.border = element_rect(color = "black", fill = NA),
   plot.title = element_text(face = "plain", size = rel(1), hjust = 0),
   plot.subtitle = element_text(face = "plain", size = rel(0.8)),
   axis.title = element_text(face = "plain",size = rel(1)),
   axis.title.x = element_text(vjust = -2),
   axis.title.y = element_text(angle = 90, vjust = 2),
   text = element_text(),
   axis.text = element_text(size = rel(0.8)), 
   axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5),
   axis.text.y = element_text(), 
   #axis.line = element_line(colour = "black"),
   axis.ticks = element_line(),
   legend.title = element_text(size = rel(1)),
   legend.text = element_text(size = rel(0.8), margin = margin(t = 2, b = 2, unit = "mm")),
   legend.key = element_rect(color = NA),
   legend.background = element_rect(fill = NA, colour = NA),
   legend.position = "right",
   legend.direction = "vertical",
   legend.spacing.x = unit(2, "mm"),
   legend.spacing.y = unit(0, "mm"),
   legend.key.size = unit(2, "mm"),
   plot.margin = unit(c(2,2,2,2), "mm"),
   strip.background = element_rect(color = "black", fill = "grey"),
   strip.text = element_text(face = "plain")
    ))
}
###
theme_set(theme_mec())
#image widths: 80 mm (one column), 112 mm (two-thirds page), 169 mm (two columns)
```

## Import sample metadata, counts data, and gene annotation
```{r data, echo=TRUE}
samples <- read.table("./data/EAPSI_samples_AxH_meta.txt", header = TRUE)
samples$SampleID <- gsub('-','.', samples$SampleID)
# Import and tidy counts data
countdata <- read.delim("./outputs/STARcounts_Pdam/AxH_Pdam.counts", comment.char="#")
# Set Gene ID's as row names
row.names(countdata) <- countdata$Geneid
# Remove first six columns (Geneid, chr, start, end, strand, length)
countdata <- countdata[ ,7:ncol(countdata)]
#countdata <- countdata[ ,6:ncol(countdata)]
# Remove file prefixes and suffixes
  colnames(countdata) <- gsub("X.", "", colnames(countdata))
  colnames(countdata) <- gsub("scratch.projects.transcriptomics.mikeconnelly.projects.EAPSI_Pocillopora_AxH.outputs.STARalign_Pdam.", "", colnames(countdata))
  colnames(countdata) <- gsub("_PdamAligned.out.bam$", "", colnames(countdata))
# Sort countdata by P. damicornis gene ID
countdata.sorted <- as.data.frame(countdata[order(rownames(countdata)),])
```
```{r gene data}
gene_annotation <- read.delim(file = "./data/pdam_genome_annotations.tab", header = T) %>% arrange(ID)
rownames(gene_annotation) <- gene_annotation$ID
# Check gene feature annotation and countdata rowname order coherence
all(rownames(countdata.sorted) == gene_annotation$ID)
all(rownames(countdata.sorted) ==  rownames(gene_annotation))
# Obtain KOG annotations for P. damicornis genome
gene2kog <- gene_annotation %>%
  select(ID, KOG_Class) %>% 
  filter(KOG_Class != "")
```
```{r coldata}
# Get sample data into tibble
coldata <- samples %>%
  as_tibble(.) %>%
  select(SampleID, Colony, Treatment, Batch)
coldata <- coldata %>%
  mutate(Colony.Treatment = interaction(Colony, Treatment)) %>%
  mutate_if(is.character, as.factor) %>% 
  arrange(SampleID) %>% #Order rows by sample name                         
  column_to_rownames(var = "SampleID")  
# Gather raw counts into tibble
colcounts <- countdata.sorted %>%
  rownames_to_column("gene") %>%
  as_tibble(.) %>%
  gather(key = "SampleID", value = "count", -gene)
```
```{r heatmap_annotation}
# ComplexHeatmap colors
col_fun_ge <- function(mat) {
  colorRamp2(c(max(mat), max(mat)/2, mean(mat), min(mat)/2, min(mat)), c("red", "yellow", "grey10", "cyan", "blue"))
}
col_fun_cor <- colorRamp2(c(1, 0.5, 0, -0.5, -1), c("red", "yellow", "grey10", "cyan", "blue"))
# ComplexHeatmap sample annotations
sample_annotation <- HeatmapAnnotation(Colony = samples$Colony,
                                       Treatment = samples$Treatment,
                                       col = anno_colors,
                                       annotation_name_rot = 0,
                                       show_legend = FALSE
                                       )
treatment_annotation <- HeatmapAnnotation(Treatment = c("control", "Heat", "Antibiotics", "Antibiotics.Heat"),
                                          col = anno_colors[2])
```
## Create DESeqDataSet
```{r create_dds}
# Create full DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = countdata.sorted,
                              colData = coldata,
                              design = ~ Colony)
# Check annotation and dds object rowname order coherence
all(rownames(dds) == rownames(gene_annotation))
# Add gene feature annotation to DESeqDataSets
mcols(dds) <- cbind(mcols(dds), gene_annotation)
# Subset DESeqDataSet
# Remove genes counted less than 10 times in dataset
dds <- dds[ rowSums(counts(dds)) > 10, ]
```

## Visualize global gene expression
```{r vst}
# Normalize expression data for visualization purposes using VST tranformation
vsd <- vst(dds, blind = TRUE) # use blind = TRUE to not account for experimental design
```
```{r}
ggPCA(vsd, samples, condcolors_AxH, pclab = c(1,2))
```
### Principal Coordinate Analysis (PCoA)
```{r mds, eval = TRUE}
# Calculate distances among samples
sampleDists <- dist(t(assay(vsd)), method = "manhattan")
sampleDistMatrix <- as.matrix(sampleDists)

# Calculate MDS
mds <- as.data.frame(colData(vsd)) %>% 
  cbind(cmdscale(sampleDistMatrix))
```
```{r colony pcoa}
# Calculate Colony centroids for plotting
mds_col <- mds %>% 
  group_by(Colony) %>%
  dplyr::summarise(c1 = mean(`1`), c2 = mean(`2`)) %>%    
  full_join(mds)
# set factor orders 
mds_col$Colony <- factor(mds$Colony, levels = c("HW1", "HW2", "WT1", "WT2"), ordered = TRUE)
mds_col$Treatment <- factor(mds$Treatment, levels = c("control", "Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE)

# Plot with spiders
pcoa1 <- ggplot(mds_col, aes(fill = Treatment)) +
  geom_segment(mapping = aes(x = `1`, y = `2`, xend = c1, yend = c2),
               lwd = 0.25, col = "dark grey") +
  # colony centroid points
  geom_point(size = 4, aes(x = c1, y = c2, color = Colony, shape = Colony), stroke = 2, fill = "black", show.legend = TRUE) +
  # sample points
  geom_point(size = 3, aes(x = `1`, y = `2`, fill = Treatment, shape = Colony), color = "black", stroke = 0.5, show.legend = FALSE) +
  scale_color_manual(values = colcolors) +
  scale_fill_manual(values = condcolors_AxH) +
  scale_shape_manual(values = colshapes) +
  labs(x = "PC1", y = "PC2") +
  coord_fixed(1) +
  guides(fill = guide_legend(override.aes = list(fill = condcolors_AxH, shape = 21, alpha = 1, stroke = 0.5))) +
  theme(legend.spacing.y = unit(0, "cm")) 
pcoa1title <- expression(paste("PCoA of overall ", italic("Pocillopora"), " spp. gene expression"))
pcoa1 <- pcoa1 + ggtitle(pcoa1title, subtitle = "Plotted with colony centroids")
pcoa1
ggsave(pcoa1, filename = "./outputs/DESeq-results/figures/pcoa_colony.pdf", width = 80, height = 80, units = "mm", device = "pdf")
ggsave(pcoa1, filename = "./manuscript_figures/Fig1_PCoA_Colony.pdf", width = 80, height = 80, units = "mm", device = "pdf")
```
```{r treatment pcoa}
# Calculate Treatment centroids for plotting
mds_trmt <- mds %>%
  group_by(Treatment) %>%
  dplyr::summarise(c1 = mean(`1`), c2 = mean(`2`)) %>%    
  full_join(mds)
#set factor orders 
mds_trmt$Colony <- factor(mds_trmt$Colony, levels = c("HW1", "HW2", "WT1", "WT2"), ordered = TRUE)
mds_trmt$Treatment <- factor(mds_trmt$Treatment, levels = c("control", "Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE)

# Plot with spiders
pcoa2 <- ggplot(mds_trmt, aes(fill = Treatment)) +
  # treatment ellipses
  # stat_ellipse(aes(x = `1`, y = `2`, color = Treatment, fill = Treatment), geom = "polygon", type = "norm", alpha = 0.0) + 
  # sample-centroid spiders paths
  geom_segment(mapping = aes(x = `1`, y = `2`, xend = c1, yend = c2),
               lwd = 0.25, col = "dark grey") +
  # treatment centroid points
  geom_point(size = 3, aes(x = c1, y = c2, color = Treatment), fill = "black", shape = 21, stroke = 2, show.legend = TRUE) +
  # sample points
  geom_point(size = 3, aes(x = `1`, y = `2`, fill = Treatment, shape = Colony), color = "black", stroke = 0.5, show.legend = FALSE) +
  scale_color_manual(values = condcolors_AxH) +
  scale_fill_manual(values = condcolors_AxH) +
  scale_shape_manual(values = colshapes) +
  labs(x = "PC1", y = "PC2") +
  coord_fixed(1) +
  guides(shape = guide_legend(override.aes = list(shape = colshapes, alpha = 1, stroke = 0.5)))
# pcoa2title <- expression(paste("PCoA of ", italic("Pocillopora"), " coral gene expression"))
# pcoa2 <- pcoa2 + ggtitle(pcoa2title, subtitle = "Plotted with treatment centroids")
pcoa2
ggsave(pcoa2, filename = "./outputs/DESeq-results/figures/pcoa_treatment.pdf", width = 112, height = 80, units = "mm", device = "pdf")
ggsave(pcoa2, filename = "./manuscript_figures/Fig1A_PCoA_Treatment.pdf", width = 112, height = 80, units = "mm", device = "pdf")
```

### Variance partition
Partition total transcriptome variance among explanatory factors including sequencing batch, colony/genotype, treatment, and their interaction.
```{r varpart_total}
varformula <- ~ (1|Batch) + (1|Colony) + (1|Treatment) #+ (1|Treatment:Colony)
varpart_total <- fitExtractVarPartModel(assay(vsd), varformula, coldata)
# sort variables (i.e. columns) by median fraction of variance explained
vpt <- sortCols(varpart_total)
# Violin plot of contribution of each variable to total variance
varplot <- plotVarPart(vpt, col = varcolors)
vartitle <- expression(paste(italic("Pocillopora"), " spp. transcriptome variance partition"))
varplot <- varplot + ggtitle(vartitle)
ggsave(varplot, filename = "./manuscript_figures/FigS6_variancePartition_total.pdf", width = 120, height = 85, units = "mm", device = "pdf")
```
```{r varpart_sum}
vptdf <- as.data.frame(vpt) %>% rownames_to_column("gene")
varpct <- vptdf %>% pivot_longer(cols = -gene, names_to = "source", values_to = "value") %>% 
  mutate(relvar = value / sum(value)) %>%
  group_by(source) %>% 
  filter(source != "Residuals") %>%
  summarise(total_pctvar_explained = sum(relvar)*100) %>% 
  arrange(desc(total_pctvar_explained))
#
varpct
```

## Differential gene expression analysis (DESeq2)
```{r genotypic DESeq}
#First, genotype-specific treatment models
design(dds) <- formula(~ Batch + Colony.Treatment)
#Set control treatment as reference factor level
dds$Treatment <- factor(dds$Treatment, levels = c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
dds$Colony.Treatment <- relevel(dds$Colony.Treatment, ref = "HW1.control")
#Perform DESeq2 analysis
dsr1 <- DESeq(dds)
resultsNames(dsr1)
# Define contrasts
contrasts <- tibble(num = c("Heat", "Antibiotics", "Antibiotics.Heat", rep("Antibiotics.Heat", 2)), 
                    den = c(rep("control", 3), "Heat", "Antibiotics"))
# Create tibble with DESeq results for all treatment contrasts for each colony
DE <- crossing(Colony = c("HW1", "HW2", "WT1", "WT2"), contrasts) %>%
   mutate(dsr = pmap(list(Colony, num, den), function(x, y, z) {
   results(dsr1, contrast = c("Colony.Treatment", paste0(x, ".", c(y, z))))}))
```
```{r overall DESeq}
#Second, overall colony and treatment interaction model
design(dds) <- formula(~ Batch + Colony + Treatment)
#Set control treatment as reference factor level
dds$Treatment <- factor(dds$Treatment, levels = c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
dds$Treatment <- relevel(dds$Treatment, ref = "control")
#Perform DESeq2 analysis
dsr2 <- DESeq(dds)
resultsNames(dsr2)
# Get DESeq results for all treatment contrasts
DE <- crossing(Colony = "all", contrasts) %>%
  mutate(dsr = map2(num, den, ~ results(dsr2, contrast = c("Treatment", .x, .y)))) %>%
  bind_rows(DE)
```
```{r DE_check}
DE
```
```{r DEG table}
DE <- DE %>%
  mutate(df = map(dsr, ~ rownames_to_column(data.frame(.), "ID")),
         df = map(df, ~ left_join(., gene_annotation, by = "ID")))
# Filter out significant up and down-regulated genes
DE <- DE %>%
  mutate(sig = map(df, ~ filter(., padj < 0.05)),
          up = map(sig, ~ filter(., log2FoldChange > 0)),
        down = map(sig, ~ filter(., log2FoldChange < 0))) 

# Generate signed logP values for all differential expression contrasts
DE <- DE %>% mutate(logP = map(dsr, ~ data.frame(
  gene = rownames(data.frame(.)),
  logP = -log10(data.frame(.)$pvalue) * sign(data.frame(.)$log2FoldChange))))

# Count number of differentially expressed genes within each colony, and overall, for each contrast
DEtab <- DE %>%
  mutate(nsig = map_dbl(sig, ~ nrow(.)),
         nup = map_dbl(up, ~ nrow(.)),
         ndn = map_dbl(down, ~ nrow(.)),
         `DEGs [up, down]` = paste0(nsig, " [", nup, ", ", ndn, "]")) %>%
  mutate(Colony = factor(Colony, levels = c("all", "HW1", "HW2", "WT1", "WT2"))) %>%
  select(Colony, num, den, `DEGs [up, down]`)

DE_table <- DEtab %>% filter(den == "control") 
write_csv(DE_table, "./outputs/DESeq-results/tables/DE_table.csv")
```
The next chunk writes out the results tables as comma-separated files for all the differential expression results contrasts, with gene ID and annotation information for preparation as a supplemental table.
Next, I want to bring together the overall and genotype model LFC and padj values for each treatment contrast into a single table.

```{r sig_tables}
# Write significant DEG results tables to csv files
DE %>%
  filter(den == "control") %>%
  mutate(sig_file_out = paste0(num, "_", den, "_", Colony, "_", "sig", ".csv"),
         sig_file_out_path = file.path("./outputs/DESeq-results/tables/sig/", sig_file_out),
         data = walk2(sig, sig_file_out_path, write_csv))
# Write ALL DEG results tables to csv files
DE %>%
  filter(den == "control") %>%
  mutate(file_out = paste0(num, "_", den, "_", Colony, "_", "all", ".csv"),
         file_out_path = file.path("./outputs/DESeq-results/tables/all/", file_out),
         data = walk2(df, file_out_path, write_csv))
# Why are there only 14 differentially expressed genes between the heat and control samples? --> Missing samples...low counts...interaction effect? 
```
### Assess similarity of responses across colonies
```{r DEgenes_colony_comparison}
shared_DEGs_colonies <- DE %>%
  unnest(sig) %>%
  filter(Colony != "all") %>%
  group_by(num, den) %>%
  dplyr::count(ID, log2FoldChange > 0) %>%   # In how many colonies is same gene DE in same direction?
  summarise(`1 colony` = sum(n==1), `2 colonies` = sum(n==2), `3 colonies` = sum(n==3), `4 colonies` = sum(n==4))
```
### Assess similarity of responses across treatments
```{r DEgenes_treatment_comparison}
shared_DEGs_treatments <- DE %>%
  unnest(sig) %>%
  #filter(Colony == "all") %>%
  filter(den == "control") %>% 
  group_by(Colony) %>%
  dplyr::count(ID, log2FoldChange > 0) %>% #View()
  summarise(`1 treatment` = sum(n==1), `2 treatments` = sum(n==2), `3 treatments` = sum(n==3))
```

```{r}
ressig_heat <- DE$sig[DE$num == "Heat" & DE$den == "control" & DE$Colony == "all"][[1]]$ID
ressig_anti <-  DE$sig[DE$num == "Antibiotics" & DE$den == "control" & DE$Colony == "all"][[1]]
ressig_anti.heat <-  DE$sig[DE$num == "Antibiotics.Heat" & DE$den == "control" & DE$Colony == "all"][[1]]$ID
```
```{r}
AH <- intersect(ressig_anti, ressig_heat)
AX <- intersect(ressig_anti, ressig_anti.heat)
HX <- intersect(ressig_heat, ressig_anti.heat)
AXH <- intersect(intersect(ressig_anti, ressig_heat), ressig_anti.heat)

length(dplyr::setdiff(ressig_anti, ressig_anti.heat))
length(dplyr::setdiff(ressig_heat, ressig_anti.heat))
length(dplyr::setdiff(ressig_anti, ressig_heat))
```
```{r treatment_venn}
pdf(file = "./outputs/DESeq-results/figures/Venn_AXH.pdf", height = 4, width = 4)
vp = viewport(height = unit(4, "in"),  width = unit(4, "in"))
grid.newpage()
grid.rect(vp = vp, gp = gpar(col = "white"))

OverVenn <- draw.triple.venn(area1 = length(ressig_anti),
                             area2 = length(ressig_heat),
                             area3 = length(ressig_anti.heat),
                             n12 = length(AH),
                             n13 = length(AX),
                             n23 = length(HX),
                             n123 = length(AXH),
                             #category = c("Antibiotics", "Heat", "Antibiotics + Heat"),
                             fill = c("#99FFFF", "#FFCC99", "#FFFF66"),
                             lwd = rep(1,3),
                             #cat.cex = rep(1.5, 3),
                             #cat.fontfamily = rep("Arial", 3),
                             #cat.fontface = rep("bold", 3),
                             alpha = c(rep(0.5, 3)),
                             cex = c(rep(2, 4), 3, rep(2, 2)),
                             fontface = c(rep("plain", 4), "bold", rep("plain", 2)),
                             fontfamily = c(rep("Arial", 7)),
                             label.col = c(rep("black", 4), "black", rep("black", 2)),
                             print.mode = "raw",
                             sigdigs = 2,
                             euler.d = TRUE,
                             overrideTriple = "override",
                             scaled = FALSE)
grid.draw(OverVenn)
```
```{r treatent_eulerr}
axh_list <- c(279, 54, 6775, 8, 605, 590, 126)
names(axh_list) <- c("H", "A", "X", "H&A", "H&X", "A&X", "H&A&X")
fit <- euler(axh_list, shape = "ellipse")
treatment_euler <- plot(fit,
     #main = list(label = "Euler diagram of DEGs in treatment contrasts", fontsize = 10, fontface = 1, hjust = 0.5), 
     quantities = list(type = c("counts"), fontsize = 8),
     labels = identical(legend, FALSE),
     fills = list(fill = condcolors_AxH[2:4], alpha = 1),
     edges = list(lwd = 0.5),
     legend = FALSE, 
     adjust_labels = TRUE)
treatment_euler
ggsave(plot = treatment_euler, filename = "./outputs/DESeq-results/figures/Euler_AXH.pdf", width = 80, height = 80, units = "mm", device = "pdf")
ggsave(plot = treatment_euler, filename = "./manuscript_figures/Fig1B_AXH_Euler.pdf", width = 70, height = 70, units = "mm", device = "pdf")
```


### DESeq results visualizations
### Volcano plots

For each of these plot styles, create data handling and plotting functions to process essential inputs into the plot
```{r}

```
```{r}
all_anti.control_volcano <- volcanoplot(DE$dsr[[1]])
ggsave(filename = "./outputs/DESeq-results/figures/all_anti.control_volcano.pdf", height = 3, width = 4, device = "pdf")
```


### Gene expression heatmaps
```{r sampleheatmap}
## Sample Clustering Heatmap
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix( sampleDists )

sample_heatmap <- pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colonyclustercol,
         annotation_colors = anno_colors,
         annotation_col = anno_col,
         annotation_row = anno_col,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         show_rownames = TRUE,
         fontsize_row = 8,
         show_colnames = FALSE,
         fontsize_col = 10,
         treeheight_col = 50,
         cutree_cols = 4,
         treeheight_row = 50,
         cutree_rows = 4)
```
```{r vargeneheatmap, message = FALSE, warning = FALSE}
### Create top variable gene expression matrix 
#Create heatmap matrix and annotation groupings
nvar <- 500
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), nvar)
matvar  <- assay(vsd)[ topVarGenes, ]
rownames(matvar) <- rowData(vsd)$ID[topVarGenes]
matvar  <- matvar - rowMeans(matvar)
###
Heatmap(matvar,
        col = col_fun_ge(matvar),
        top_annotation = sample_annotation)
```
```{r deg_heatmaps}
### Create differentially expressed gene matrix 
#Create heatmap matrix and annotation groupings
mat_genes  <- assay(vsd)[DE$sig[[5]]$ID, ]
row.names(mat_genes) <- DE$sig[[5]]$ID#[1:95]
mat_genes <- mat_genes - rowMeans(mat_genes)
```



### Gene counts boxplots
```{r}
for (i in 1:10) {
  genoboxplot(DE$sig[[5]]$ID[i])
}
```

### Double-treatment plots

### DESeq Gene Ontology (GO) enrichment analysis
### Heat vs. control 
```{r heat signed logP}
# Write overall Heat vs. control logP values to file for GO_MWU analysis
DE %>%
  filter(Colony == "all", num == "Heat", den == "control") %>%
  unnest(logP) %>%
  select(gene, logP) %>%
  write.table(., file = "./R/GO_MWU/heat.control.logP.txt", row.names = FALSE, quote = FALSE, sep = ",")
```
```{r heat GO_MWU}
# Run GO_MWU for Heat vs. control for Biological Process (BP) GO terms
commandArgs <- function(...) c("heat.control.logP.txt", "BP")
source("./R/GO_MWU/GO_MWU.R")

# Run GO_MWU for Heat vs. control for Molecular Function GO terms
commandArgs <- function(...) c("heat.control.logP.txt", "MF")
source("./R/GO_MWU/GO_MWU.R")

# Run GO_MWU for Heat vs. control for Cellular Component (CC) GO terms
commandArgs <- function(...) c("heat.control.logP.txt", "CC")
source("./R/GO_MWU/GO_MWU.R")
```
```{r heat.control_GO}
heat.control.GO <- as.list(
  c(BP = "./R/GO_MWU/MWU_BP_heat.control.logP.txt",
    MF = "./R/GO_MWU/MWU_MF_heat.control.logP.txt",
    CC = "./R/GO_MWU/MWU_CC_heat.control.logP.txt")
  ) %>% map(read.table, header = T) %>%
  bind_rows(.id = "ontology") %>%
  as_tibble() %>%
  filter(p.adj < 0.01)

heat.control.GO %>%
  select(ontology, delta.rank, p.adj, name, nseqs, level, term) %>%
  arrange(ontology, p.adj) %>% 
  write_csv(path = "./outputs/DESeq-results/GO_MWU/tables/heat.control.GO.csv")

heat.control.GO %>% filter(p.adj < 0.01 & delta.rank >= 0) %>% count(ontology)
```
```{r heat GO_MWU plot}
# Plot GO_MWU results for Heat vs. control 
commandArgs <- function(...) c("heat.control.logP.txt", "BP", "GO_MWU.heat.control.pdf", 1e-6, 1e-8, 1e-10, 1.5)
source("./R/GO_MWU/GO_MWU_plot.R")
commandArgs <- function(...) c("heat.control.logP.txt", "MF", "GO_MWU.heat.control_slim.pdf", 0.05, 0.01, 1e-3, 1)
source("./R/GO_MWU/GO_MWU_plot.R")
commandArgs <- function(...) c("heat.control.logP.txt", "CC", "GO_MWU.heat.control_slim.pdf", 0.05, 0.01, 1e-3, 1)
source("./R/GO_MWU/GO_MWU_plot.R")
```
### Antibiotics vs. control 
```{r anti signed logP}
# Write overall Antibiotics vs. control logP values to file for GO_MWU analysis
DE %>%
  filter(Colony == "all", num == "Antibiotics", den == "control") %>%
  unnest(logP) %>%
  select(gene, logP) %>%
  write.table(., file = "./R/GO_MWU/anti.control.logP.txt", row.names = FALSE, quote = FALSE, sep = ",")
```
```{r anti GO_MWU}
# Run GO_MWU for Antibiotics vs. control for Biological Process (BP) GO terms
commandArgs <- function(...) c("anti.control.logP.txt", "BP")
source("./R/GO_MWU/GO_MWU.R")

# Run GO_MWU for Antibiotics vs. control for Molecular Function GO terms
commandArgs <- function(...) c("anti.control.logP.txt", "MF")
source("./R/GO_MWU/GO_MWU.R")

# Run GO_MWU for Antibiotics vs. control for Cellular Component (CC) GO terms
commandArgs <- function(...) c("anti.control.logP.txt", "CC")
source("./R/GO_MWU/GO_MWU.R")
```
```{r anti.control_GO}
anti.control.GO <- as.list(
  c(BP = "./R/GO_MWU/MWU_BP_anti.control.logP.txt",
    MF = "./R/GO_MWU/MWU_MF_anti.control.logP.txt",
    CC = "./R/GO_MWU/MWU_CC_anti.control.logP.txt")
  ) %>% map(read.table, header = T) %>%
  bind_rows(.id = "ontology") %>%
  as_tibble() %>%
  filter(p.adj < 0.01)

anti.control.GO %>%
  select(ontology, delta.rank, p.adj, name, nseqs, level, term) %>%
  arrange(ontology, p.adj) %>% 
  write_csv(path = "./outputs/DESeq-results/GO_MWU/tables/anti.control.GO.csv")

anti.control.GO %>% filter(p.adj < 0.01 & delta.rank >= 0) %>% count(ontology)
```
```{r anti GO_MWU plot}
# Plot GO_MWU results for Antibiotics vs. control 
commandArgs <- function(...) c("anti.control.logP.txt", "BP", "GO_MWU.anti.control.pdf", 1e-3, 1e-4, 1e-5, 1.5)
source("./R/GO_MWU/GO_MWU_plot.R")
commandArgs <- function(...) c("anti.control.logP.txt", "MF", "GO_MWU.anti.control_slim.pdf", 5e-2, 1e-2, 1e-3, 1.0)
source("./R/GO_MWU/GO_MWU_plot.R")
commandArgs <- function(...) c("anti.control.logP.txt", "CC", "GO_MWU.anti.control_slim.pdf", 5e-2, 1e-2, 1e-3, 1.0)
source("./R/GO_MWU/GO_MWU_plot.R")
```
### Antibiotics.Heat vs. control 
```{r anti.heat signed logP}
# Write overall Antibiotics.Heat vs. control logP values to file for GO_MWU analysis
DE %>%
  filter(Colony == "all", num == "Antibiotics.Heat", den == "control") %>%
  unnest(logP) %>%
  select(gene, logP) %>%
  write.table(., file = "./R/GO_MWU/anti.heat.control.logP.txt", row.names = FALSE, quote = FALSE, sep = ",")
```
```{r anti.heat GO_MWU}
# Run GO_MWU for Antibiotics.Heat vs. control for Biological Process (BP) GO terms
commandArgs <- function(...) c("anti.heat.control.logP.txt", "BP")
source("./R/GO_MWU/GO_MWU.R")

# Run GO_MWU for Antibiotics.Heat vs. control for Molecular Function GO terms
commandArgs <- function(...) c("anti.heat.control.logP.txt", "MF")
source("./R/GO_MWU/GO_MWU.R")

# Run GO_MWU for Antibiotics.Heat vs. control for Cellular Component (CC) GO terms
commandArgs <- function(...) c("anti.heat.control.logP.txt", "CC")
source("./R/GO_MWU/GO_MWU.R")
```
```{r anti.heat.control_GO}
anti.heat.control.GO <- as.list(
  c(BP = "./R/GO_MWU/MWU_BP_anti.heat.control.logP.txt",
    MF = "./R/GO_MWU/MWU_MF_anti.heat.control.logP.txt",
    CC = "./R/GO_MWU/MWU_CC_anti.heat.control.logP.txt")
  ) %>% map(read.table, header = T) %>%
  bind_rows(.id = "ontology") %>%
  as_tibble() %>%
  filter(p.adj < 0.01)

anti.heat.control.GO %>%
  select(ontology, delta.rank, p.adj, name, nseqs, level, term) %>%
  arrange(ontology, p.adj) %>% 
  write_csv(path = "./outputs/DESeq-results/GO_MWU/tables/anti.heat.control.GO.csv")

anti.heat.control.GO %>% filter(p.adj < 0.01 & delta.rank >= 0) %>% count(ontology)
```
```{r anti.heat GO_MWU plot}
# Plot GO_MWU results for Antibiotics.Heat vs. control 
commandArgs <- function(...) c("anti.heat.control.logP.txt", "BP", "GO_MWU.anti.heat.control_slim.pdf", 5e-2, 1e-2, 1e-3, 1.0)
source("./R/GO_MWU/GO_MWU_plot.R")
commandArgs <- function(...) c("anti.heat.control.logP.txt", "MF", "GO_MWU.anti.heat.control_slim.pdf", 5e-2, 1e-2, 1e-3, 1.0)
source("./R/GO_MWU/GO_MWU_plot.R")
commandArgs <- function(...) c("anti.heat.control.logP.txt", "CC", "GO_MWU.anti.heat.control_slim.pdf", 5e-2, 1e-2, 1e-3, 1.0)
source("./R/GO_MWU/GO_MWU_plot.R")
```
```{r allGO}
#Supplemental table with all GO results
allGO <- bind_rows(.id = "contrast",
  heat.control = heat.control.GO,
  anti.control = anti.control.GO,
  anti.heat.control = anti.heat.control.GO
) %>%
  select(contrast, ontology, delta.rank, name, p.adj) %>%
  arrange(contrast, ontology, sign(delta.rank), p.adj)

write_csv(allGO, path = "./outputs/DESeq-results/GO_MWU/allGO.csv")
```
### DESeq EuKaryotic Orthologous Groups (KOG) enrichment analysis
```{r KOG, results = 'hide'}
# Using the signed log(p-values) from the differential expression analysis, we can analyze which KOG classifications are up- or down-regulated within each colony, and across all four colonies together.
# Ensure gene KOG annotation is present
head(gene2kog)
# Run KOG.MWU analysis on all contrasts
KOG <- DE %>%
  mutate(KOG = map(logP, ~ kog.mwu(., gene2kog)),
         # If a KOG term has <10 genes associated with it, set delta rank to zero
         KOG = map(KOG, ~ mutate(., delta.rank = ifelse(nseqs < 10, 0, delta.rank))))

# Generate all KOG delta rank tables
kogtables <- KOG %>%
  unnest(KOG) %>%
  select(Colony, num, den, term, delta.rank) %>% 
  split(list(.$num, .$den), drop = TRUE) %>% 
  map(~ spread(., Colony, delta.rank)) %>% 
  map(~ column_to_rownames(select(., -num, -den), "term"))

# Generate KOG p-value stars
kogpvals <- KOG %>%
  unnest(KOG) %>%
  select(Colony, num, den, term, padj) %>%
  split(list(.$num, .$den), drop = TRUE) %>%
  map(~ spread(., Colony, padj)) %>%
  map(~ column_to_rownames(select(., -num, -den), "term")) %>%
  map(~ transmute_all(., gtools::stars.pval))
```
```{r KOG_heatmaps}
KOG_heat.control <- KOGheatmap(kogtables$Heat.control, kogpvals$Heat.control, main = "Heat vs. Control", 
                      fontsize = 6)
ggsave(filename = "./outputs/DESeq-results/KOGMWU/figures/KOGheat.control.pdf", plot = KOG_heat.control, width = 80, height = 85, units = "mm", device = "pdf")
KOG_anti.control <- KOGheatmap(kogtables$Antibiotics.control, kogpvals$Antibiotics.control, main = "Antibiotics vs. Control", 
                      fontsize = 6)
ggsave(filename = "./outputs/DESeq-results/KOGMWU/figures/KOGanti.control.pdf", plot = KOG_anti.control, width = 80, height = 85, units = "mm", device = "pdf")
KOG_anti.heat.control <- KOGheatmap(kogtables$Antibiotics.Heat.control, kogpvals$Antibiotics.Heat.control, main = "Antibiotics + Heat vs. Control", 
                      fontsize = 6)
ggsave(filename = "./outputs/DESeq-results/KOGMWU/figures/KOGanti.heat.control.pdf", plot = KOG_anti.heat.control, width = 80, height = 85, units = "mm", device = "pdf")
```
```{r KOG_treatment contrasts}
kogtable_contrasts <- KOG %>%
  unnest(KOG) %>%
  filter(Colony == "all") %>%
  select(num, den, term, delta.rank) %>%
  unite("contrast", num, den, sep = ".") %>%
  spread(contrast, delta.rank) %>%
  column_to_rownames("term")
  
kogpval_contrasts <- KOG %>%
  unnest(KOG) %>%
  filter(Colony == "all") %>%
  select(num, den, term, padj) %>%
  unite("contrast", num, den, sep = ".") %>%
  spread(contrast, padj) %>%
  column_to_rownames("term") %>%
  transmute_all(gtools::stars.pval)

kog_contrasts <- bind_cols(kogtable_contrasts, kogpval_constrasts)
write_csv(kog_contrasts, path = "./outputs/DESeq-results/KOGMWU/kog_contrasts.csv")

KOGtitle <- expression(plain("Heatmap of KOG classes delta ranks"))
contrast_labs <- c(expression("Heat"~"vs."~"Control"),
                 expression("Antibiotics"~"vs."~"Control"),
                 expression("Antibiotics.Heat"~"vs."~"Control"))

KOG_treatments <- KOGheatmap(
  select(kogtable_contrasts, Heat.control, Antibiotics.control, Antibiotics.Heat.control),
  select( kogpval_constrasts, Heat.control, Antibiotics.control, Antibiotics.Heat.control),
  labels_col = contrast_labs,
  #main = KOGtitle,
  fontsize = 8,
  fontsize_row = 7,
  fontsize_col = 8)

ggsave(filename = "./outputs/DESeq-results/KOGMWU/figures/KOG_treatment_heatmap.pdf", KOG_treatments, width = 80, height = 85, units = "mm")
ggsave(filename = "./manuscript_figures/Fig1C_KOGheatmap.pdf", KOG_treatments, width = 112, height = 92, units = "mm")
```

## Discriminant analysis of principal components (DAPC)
```{r DAPC}
# use this link to follow: http://adegenet.r-forge.r-project.org/files/tutorial-dapc.pdf
# Discriminant function including all genes
# use regular vst counts
dat <- data.frame(assay(vsd))
# use batch-colony-removed vst counts - no major difference
# vsd_col <- limma::removeBatchEffect(assay(vsd), vsd$Colony)
# dat <- data.frame(vsd_col) 

# How many PCs should be kept?
dapcopt <- dapc(t(dat), colData(dds)$Treatment, n.da=100, n.pca=46)
a.score(dapcopt)
temp <- optim.a.score(dapcopt, n.sim = 5)
names(temp)
my.dapc <- function(n.pca) dapc(t(dat), colData(dds)$Treatment, n.pca = n.pca, n.da = 4)

# library(furrr)
# plan(multiprocess)
# my.dapc.res <- tibble(n.pca = 5:20) %>%
#   mutate(dapc = map(n.pca, my.dapc),
#          a.score = furrr::future_map(dapc, a.score, n.sim = 1000),
#          mean = map_dbl(a.score, ~ .$mean),
#          cumvar = map_dbl(dapc, ~ .$var))
# 
# my.dapc.res %>%
#   arrange(-mean) %>%
#   head()

# Retaining 7 PC's gives highest a-score (44%) but only utilizes 75% of the cumulative variance. Retaining 11 PC's gives a high a-score and uses 83% of cumulative variance. Therefore, let's use 11 PC's for the DA. 

dp1 <- dapc(t(dat), colData(dds)$Treatment,
            n.pca = 11, n.da = 2)   # Retain 11 PCs and 2 discriminant functions
scatter(dp1, bg="white", scree.da=TRUE, scree.pca=TRUE, legend=TRUE) 
# Axis one represents antibiotics treatment response, Axis two represents the heat stress response.

dapc <- tibble(SampleID = rownames(dp1$ind.coord),
               grp = dp1$grp,
               Colony = coldata$Colony,
               Treatment = coldata$Treatment,
               LD1 = dp1$ind.coord[,1],
               LD2 = dp1$ind.coord[,2])
dapc <- dapc %>%
  group_by(grp) %>%
  summarize(c1 = mean(LD1),
            c2 = mean(LD2)) %>%
  full_join(dapc) 
#set factor orders 
dapc$Colony <- factor(dapc$Colony, levels = c("HW1", "HW2", "WT1", "WT2"), ordered = TRUE)
dapc$Treatment <- factor(dapc$Treatment, levels = c("control", "Heat", "Antibiotics", "Antibiotics.Heat"), ordered = TRUE)
```
```{r dapc_spider}
# Plot with spiders
dapc.fig <- 
  ggplot(dapc, aes(fill = Treatment)) +
  #sample-centroid spiders paths
  geom_segment(mapping = aes(x = LD1, y = LD2, xend = c1, yend = c2), lwd = 0.25, col = "dark grey") +
  #treatment centroid points
  geom_point(aes(x = c1, y = c2, color = Treatment), size = 4, fill = "black", shape = 21, stroke = 2, show.legend = FALSE) +
  #sample points
  geom_point(aes(x = LD1, y = LD2, shape = Colony), size = 3, show.legend = FALSE) +
  scale_color_manual(values = condcolors_AxH) +
  scale_shape_manual(name = "Colony", values = colshapes) +
  scale_fill_manual(name = "Treatment", values = condcolors_AxH) +
  guides(shape = guide_legend(override.aes = list(shape = colshapes))) +
  theme(plot.margin = unit(c(-0.5, -0.5, 0.5, 0.5), "cm")) +
 # guides(shape = guide_legend(override.aes = list(fill = "black", size = 2))) +
  labs(x = "LD1", y = "LD2")
dapc.fig
```
```{r dapc_plot}
xplot <- 
  ggdensity(dapc, x = "LD1", fill = "Treatment", lwd = 0.5,
            palette = condcolors_AxH) +
  clean_theme() + rremove("legend") +
  theme(plot.margin = unit(c(0.0, 0, -0.1, 0), "cm"))
#ggplot(dapc, aes(x = LD1, fill = grp)) + geom_density(alpha = 0.5, adjust = 1)
# xplot

yplot <- 
  ggdensity(dapc, x = "LD2", fill = "Treatment", lwd = 0.5,
            palette = condcolors_AxH) +
  clean_theme() + rremove("legend") + 
  theme(plot.margin = unit(c(0, 0.0, 0, -0.1), "cm")) + ggpubr::rotate()
# yplot 

dapcplot <- plot_grid(xplot, NULL, dapc.fig, yplot,
                      nrow = 2, ncol = 2,
                      align = "hv",
                      #axis = "tblr",
                      rel_widths = c(3, 1),
                      rel_heights = c(1, 3),
                      greedy = FALSE)
dapcplot
ggsave(filename = "./manuscript_figures/Fig2_DAPC.pdf", plot = dapcplot, width = 120, height = 115, units = "mm", device = "pdf")
# The DAPC clearly shows two distinct axes of stress responses among the antibiotics, heat stress, and combined stressors. 
# The first linear discriminant function (LD1) separates antibiotics-treated fragments from non-treated fragments in the control and heat stress treatments.
# The second linear discriminant function (LD2) separates heat-stressed fragments from ambient temperature fragments in the control and antibiotics treatments.
```
```{r dapc_varcontr}
dp1
summary(dp1)
# dp1$tab
dpvarc <- as.data.frame(dp1$var.contr) %>%
  rownames_to_column("ID") %>% left_join(gene_annotation, by = "ID") %>%
  arrange(desc(LD1))
```
```{r dapc_loadingplot}
set.seed(4)
par(mfrow = c(2,1))
contrib1 <- loadingplot(dp1$var.contr, axis=1, 
                       thres=.025,
                       lab.jitter=2)
contrib2 <- loadingplot(dp1$var.contr, axis=2, 
                       thres=.025,
                       lab.jitter=2)
```
```{r dapc_heatmaps_ld1}
dpvarc_ld1 <- dpvarc %>% arrange(desc(LD1))
ntop <- 10
topload_ld1 <- dpvarc_ld1$ID[1:ntop]
mat_ld1  <- assay(vsd)[topload_ld1, ]
mat_ld1 <- mat_ld1 - rowMeans(mat_ld1)
# obtain LD1 loadings and create barplot annotation
load_ld1_barplot <- HeatmapAnnotation("DAPC LD1 loading" = anno_barplot(dpvarc_ld1$LD1[1:ntop]),
                                      which = "row")
# create heatmap
pdf("./outputs/DESeq-results/figures/DAPC_LD1_10genes_heatmap_clustered.pdf", height = 8.5, width = 11)
heatmapLD1 <- Heatmap(mat_ld1,
        #row_order = rownames(mat_ld1),
        col = col_fun_ge(mat_ld1),
        top_annotation = sample_annotation,
        right_annotation = load_ld1_barplot,
        row_dend_width = unit(0.75, "in"),
        row_labels = as.character(gene_annotation[rownames(mat_ld1), 3]),
        show_heatmap_legend = TRUE,
        heatmap_legend_param = list(title = "Normalized gene expression",
                 just = c(0, 0),
                 direction = "vertical",
                 title_position = "leftcenter-rot",
                 legend_height = unit(1, "in")),
        row_names_gp = gpar(fontsize = 6, fontface = "plain"),
        column_names_gp = gpar(fontsize = 0, fontface = "plain"),
        height = unit(7, "in"),
        width = unit(4, "in"))
draw(heatmapLD1, heatmap_legend_side = "left", legend_title_gp = gpar(fontsize = 10, fontface = "plain"), padding = unit(c(0.5, -2.0, 0.5, 0.5), "in"))
```
```{r dapc_boxplots_ld1}
pdf("./outputs/DESeq-results/figures/DAPC_LD1_loadings_10genes_boxplots.pdf", height = 3.5, width = 5)
for (i in 1:10) {
  genoboxplot(dpvarc_ld1$ID[i])
}
```
```{r dapc_heatmaps_ld2}
dpvarc_ld2 <- dpvarc %>% arrange(desc(LD2))
ntop <- 10
topload_ld2 <- dpvarc_ld2$ID[1:ntop]
mat_ld2  <- assay(vsd)[topload_ld2, ]
mat_ld2 <- mat_ld2 - rowMeans(mat_ld2)
# obtain LD2 loadings and create barpot annotation
load_ld2_barplot <- HeatmapAnnotation("DAPC LD2 loading" = anno_barplot(dpvarc_ld2$LD2[1:ntop]),
                                      which = "row")
# create heatmap
pdf("./outputs/DESeq-results/figures/DAPC_LD2_10genes_heatmap_clustered.pdf", height = 8.5, width = 11)
heatmapLD2 <- Heatmap(mat_ld2,
        #row_order = rownames(mat_ld2),
        col = col_fun_ge(mat_ld2),
        top_annotation = sample_annotation,
        right_annotation = load_ld2_barplot,
        row_dend_width = unit(0.75, "in"),
        row_labels = as.character(gene_annotation[rownames(mat_ld2), 3]),
        show_heatmap_legend = TRUE,
        heatmap_legend_param = list(title = "Normalized gene expression",
                 just = c(0, 0),
                 direction = "vertical",
                 title_position = "leftcenter-rot",
                 legend_height = unit(1, "in")),
        row_names_gp = gpar(fontsize = 6, fontface = "plain"),
        column_names_gp = gpar(fontsize = 0, fontface = "plain"),
        height = unit(7, "in"),
        width = unit(4, "in"))
draw(heatmapLD2, heatmap_legend_side = "left", legend_title_gp = gpar(fontsize = 10, fontface = "plain"), padding = unit(c(0.5, -2.0, 0.5, 0.5), "in"))
```
```{r dapc_boxplots_ld2}
pdf("./outputs/DESeq-results/figures/DAPC_LD2_loadings_10genes_boxplots.pdf", height = 3.5, width = 5)
for (i in 1:10) {
  genoboxplot(dpvarc_ld2$ID[i])
}
```
```{r dapc_tests, include = FALSE, eval = FALSE}
# DAPC - axis of heat stress in C corals (Ccontrol vs. Cheat), then see where D's fall along it (sensu Kenkel and Matz)

# use batch-colony-removed vst counts
vsd2 <- vsd
#assay(vsd2) <- limma::removeBatchEffect(assay(vsd), vsd$colony)
## Subset C-control and C-heat corals
CcCh <- vsd2[, colData(vsd2)$group %in% c("Cc", "Ch")]
dat <- data.frame(assay(CcCh))

# Fit DAPC axis
dp1 <- dapc(t(dat), colData(CcCh)$group, n.pca = 12, n.da = 1)
scatter(dp1, scree.pca = T)

# Calculate values along this axis
## Subset D-control and D-heat corals
DcDh <- vsd2[, colData(vsd2)$group %in% c("Dc", "Dh")]
dat2 <- data.frame(assay(DcDh))
## Get scores for these samples along the Cc-Ch DAPC axis
pred.sup <- predict.dapc(dp1, newdata=(t(dat2)))

# Create dapc object to plot new scores
newdp <- dp1
newdp$ind.coord<-pred.sup$ind.scores
newdp$posterior<-pred.sup$posterior
newdp$assign<-pred.sup$assign
newdp$grp <- colData(DcDh)$group
scatter(newdp)

# Get scores for all groups
dpc <- tibble(group = c(as.character(dp1$grp), as.character(newdp$grp)),
              core = c(rownames(dp1$ind.coord), rownames(newdp$ind.coord)),
              colony = str_sub(core, 3, 4),
              score = c(dp1$ind.coord, newdp$ind.coord))
ggplot(dpc, aes(x = score, fill = group)) + geom_density(adjust = 1, alpha = 0.5)
ggplot(dpc, aes(x = group, y = score, shape = colony, color = colony)) + geom_point()

# Test for differences between groups
mod <- lm(score ~ group, data = dpc)
anova(mod)
lsm <- lsmeans(mod, specs = "group")
contrast(lsm, "pairwise")

# Ccontrol -- -1.94
# Cheat ---    1.94    (diff = 3.89)
# Dcontrol -- -0.16


# I deemed this approach inappropriate because we shouldn't necessarily constrain the responses of D corals to occur along an axis of heat stress for C corals... they could respond in an entirely different way along an entirely different axis. Therefore, the DAPC with all four groups is more appropriate. LD1 still ends up corresponding very strongly to the axis of heat stress for C corals, and we still C that shuffling to D moves corals toward the heat stress end of the axis. We can still do a statistical test on LD1 values for different groups. 
```
```{r loadings_scatterplot}
pdf("./outputs/DESeq-results/figures/DAPC_LD_loadings_scatterplot.pdf", height = 7, width = 7)
dpvarc %>% ggplot(., aes(x = LD1, y = LD2)) +
  geom_point() +
  xlim(c(0,0.01)) +
  ylim(c(0,0.01)) +
  geom_text_repel(data = dpvarc_ld2[1:10, ], aes(label = (dpvarc_ld2[1:10, 5])), color = "black", size = 2.5, box.padding = unit(0.35, "lines")) + ggtitle("DAPC LD gene loadings scatterplot", subtitle = "Top 10 genes LD2 labelled")
```
## Weighted gene co-expression network analysis (WGCNA)
```{r wgcna_setup_datExpr}
allowWGCNAThreads(nThreads = 4)
# obtain vst-transformed counts
countdata_vst <- assay(vsd)
# Convert to matrix and transpose, check dimensions
datExpr <- t(countdata_vst)
dim(datExpr)
```
```{r soft_threshold}
# Find correlation power R^N that satisfies scale free critereon (SFT.R.sq>0.9)
sft <- pickSoftThreshold(datExpr, verbose=5)
sft$powerEstimate
```
### Step-by-step network construction
```{r adjacency_TOM}
# This follows the tutorial: 
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# 
# I have chosen the following network construction parameters for the following reasons:
# First, following the recommendations of the WGCNA developers (https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html), a signed network was chosen to be able to detect positive and negative gene correlations, and the biweight midcorrelation was used since it is more robust to outliers. 

adjacency <- adjacency(datExpr,
      # Network construction arguments:  correlation, adjacency function,  and topological overlap map options
                       corFnc = "bicor", # bimidweight correlation
                       power=sft$powerEstimate, # 10
                       type = "signed") # signed
# 
TOM <- TOMsimilarity(adjacency,
                     TOMType = "signed",
                     verbose = 5)
dissTOM <- 1-TOM
# 
rm(adjacency) # may need to delete adjacency, TOM to clear up vector memory
```
```{r gene_dendrogram}
geneTree <- flashClust(as.dist(dissTOM), method = "average")
plot(geneTree, labels = FALSE, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity")
```
```{r dynamic_treecut}
# minModuleSize = 100 because I prefer large modules that lend themselves to enrichment tests with GO_MWU for easier interpretation.
minModuleSize <- min(100, ncol(datExpr)/5 )
# Module identification using dynamic tree cut, with cutHeight = 0.99 and deepSplit = 2 based on the recommendations of the WGCNA developers
dynamicMods <- cutreeDynamic(dendro = geneTree,
                             distM = dissTOM,
                             cutHeight = 0.99,
                             deepSplit = 2,
                             pamRespectsDendro = FALSE,
                             minClusterSize = minModuleSize)
table(dynamicMods)
# Convert numeric lables into colors
dynamicColors <- labels2colors(dynamicMods, colorSeq = standardColors())
```
```{r module_dendrogram}
# Calculate eigengenes
MEList <- moduleEigengenes(datExpr, colors = dynamicColors)
MEs <- MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss <- 1-cor(MEs);
# Cluster module eigengenes
METree <- flashClust(as.dist(MEDiss), method = "average");
# Plot the result
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
MEDissThres = 0.3
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
```
```{r merge_modules}
# Call an automatic merging function
# merge cutHeight = 0.3 because I want to group together modules with >70% similar module eigengene expression
mergedMods <- mergeCloseModules(datExpr, dynamicColors, cutHeight = 0.3, verbose = 5)
# The merged module colors
mergedColors <- mergedMods$colors
table(mergedColors)
```
```{r dendrogram_modules}
pdf(file = "./outputs/WGCNA-results/dendrogram.pdf", width = 8, height = 6)
pdf(file = "./manuscript_figures/FigS##_WGCNA_dendrogram.pdf", width = 8, height = 6)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(dendro = geneTree, 
                    colors = cbind(dynamicColors, mergedColors),
                    groupLabels = c("Dynamic modules", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    abHeight = c(0.99))
```
```{r merged_eigengenes}
MEList <- moduleEigengenes(datExpr, colors = mergedColors)
mergedMEs <- MEList$eigengenes
```
```{r choose_modules}
moduleColors <- mergedColors#netColors#
MEs1 <- mergedMEs#netMEs#
# MEs1 <- MEs1 %>% select(-MEgrey)
MEmodule_colors <- colnames(MEs1)
module_colors <- gsub("ME", "", colnames(MEs1))
colnames(MEs1) <- module_colors
```
```{r ME_clustering}
datME <- MEs1
dissimME <- (1-t(cor(datME, method="p")))/2
hclustME <- flashClust(as.dist(dissimME), method="average" )
# Plot the eigengene dendrogram
par(mfrow=c(1,1))
plot(hclustME, main="Clustering tree based on the module eigengenes")
```
### Module eigengene treatment correlations and heatmap
```{r trait_data}
# Get sample data into tibble
datTraits <- samples %>% 
  select(-Reef, -Colony, -Environment, -Treatment, -Batch, -allanti, -allheat, -Houwan, -Wanglitung) %>%
  select(SampleID, control, Heat, Antibiotics, Antibiotics.Heat) %>%
  #select(SampleID, HW1, HW2, WT1, WT2) %>%
  arrange(SampleID) %>% #Order rows by sample name                         
  column_to_rownames(var = "SampleID")
#Define numbers of genes and samples
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
```
```{r ME_correlations}
# Correlate module eigengene-trait associations
moduleTraitCor <- cor(MEs1, datTraits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)
moduleCors <- as.data.frame(moduleTraitCor, moduleTraitPvalue)
```
```{r uniq_modules}
# Extract all unique modules
uniqModules <- sort(setdiff(unique(colnames(MEs1)), "grey"))
uniqModules
```
```{r sig_modules}
# Identify all unique and interesting modules based on trait correlations
# Filter for only modules that have a significant correlation to any treatment or genotype
modP <- as.data.frame(moduleTraitPvalue) %>%
  rownames_to_column("module") %>%
  arrange(module) %>% 
  filter_all(any_vars(. < 0.05)) # %>% dplyr::select(module, lps)
sigModules <- sort(setdiff(modP$module,  "grey"))
sigModules
all(sigModules %in% uniqModules) # test that all the significant modules are actually within the modules
all(sigModules == uniqModules) # are all modules also significantly correlated to one or more traits?
```
```{r ME_textmatrix}
# Create text matrix to display correlations and their p-values
#textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 2), ")", sep = "")
# Only displays significant correlations p < 0.05
textMatrix <- character()
for (i in 1:length(moduleTraitPvalue)){
  if(moduleTraitPvalue[i] < 0.05){ text <-  paste(signif(moduleTraitCor[i], 2), "\n(", signif(moduleTraitPvalue[i], 2), ")", sep = "") } else { text <- "" }
  textMatrix[i] <- text
}
dim(textMatrix) <- dim(moduleTraitCor)
```
```{r ComplexHeatmap_annotation}
# column annotation for treatments

# annotation to include module colors
moddf <- data.frame(module_colors)
module_anno  <- module_colors
names(module_anno) <- module_colors
module_sizes <- data.frame(table(moduleColors)) %>% filter(moduleColors != "grey") %>% arrange(desc(Freq))
colnames(module_sizes) <- c("module_colors", "module_size")
moddf <- left_join(moddf, module_sizes, by = "module_colors")
module_annotation <- HeatmapAnnotation(modules = moddf$module_colors,
                                       col = list(modules = module_anno),
                                       which = "row",
                                       annotation_name_rot = 0,
                                       show_legend = FALSE
                                       )
# text matrix annotation for cell text
 cell_fun <- function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%.1f", textMatrix[i, j]), x, y, gp = gpar(fontsize = 6))
 }
# barplot annotation of module sizes
module_barplot <- HeatmapAnnotation(module_size = anno_barplot(moddf$module_size,
                                                  gp = gpar(fill = as.character(moddf$module_colors))),#module_sizes$moduleColors)),
                                    which = "row",
                                    show_legend = FALSE,
                                    width = unit(0.85, "in")
                                    )
```
```{r ME_heatmap_ComplexHeatmap}
pdf(file = "./outputs/WGCNA-results/figures/ME_complexheatmap_treatments.pdf", width = 6.5, height = 6)
#pdf(file = "./manuscript_figures/Fig4A_ME_heatmap.pdf", width = 6, height = 6)
me_heatmap <- Heatmap(moduleTraitCor,
                      #col = col_fun_cor,
                      cell_fun = function(j, i, x, y, width, height, fill) {grid.text(sprintf("%s", textMatrix[i, j]), x, y, gp = gpar(fontsize = 6))},
                      cluster_rows = hclustME,
                      top_annotation = treatment_annotation,
                      left_annotation = module_annotation,
                      # right_annotation = module_barplot,
                      row_split = NULL,
                      border = FALSE,
                      rect_gp = gpar(col = "white", lwd = 1.5),
                      column_title_gp = gpar(fontsize = 8, fontface = "plain"),
                      column_order = colnames(datTraits),
                      column_names_rot = 0,
                      column_names_side = "top",
                      column_names_centered = TRUE,
                      column_names_gp = gpar(fontsize = 8, fontface = "plain"),
                      row_dend_width = unit(1, "in"),
                      row_names_gp = gpar(fontsize = 8, fontface = "plain"),
                      show_heatmap_legend = TRUE,
                      heatmap_legend_param = list(title = "Eigengene treatment correlation",
                                                  direction = "vertical",
                                                  title_position = "leftcenter-rot",
                                                  legend_height = unit(1.0, "in"),
                      height = unit(4, "in"),
                      width = unit(3, "in"))
                      )
draw(me_heatmap, column_title = "Module eigengene treatment correlation heatmap", 
     show_annotation_legend = FALSE, heatmap_legend_side = "left"
     )
```
I would also like to...
...add treatment color annotation to top of heatmap...and fix legend label position (modules, Treatment, module_size)
...adjust legend position...
...add heatmap to show module eigengene correlations to bacteria taxa...
...include text cloud annotation based on GO enrichment...

### Module "Volcano" Plots
```{r}

```
```{r module_volcano}

```

### Module genes and hub genes
```{r modules_genes}
# Generate GeneIDs
Genes <- colnames(datExpr)
# Output genes and annotations for each module
for (module in uniqModules)
{
# Select module genes
inModule <- (moduleColors == module)
# Get gene IDs
modGeneIDs <- Genes[inModule] #this is the correct set of gene IDs!
# Write gene annotations into a file
fileName = paste("./outputs/WGCNA-results/notes/", module, ".csv", sep="");
module_annotation <- gene_annotation[modGeneIDs, ]
write_csv(module_annotation, path = fileName)
}
```
```{r hub_genes}
hubs <- chooseTopHubInEachModule(datExpr,
                         mergedColors,
                         corFnc = "bicor", # bimidweight correlation
                         power=sft$powerEstimate, # 10
                         type = "signed")
hub_genes <- gene_annotation[hubs, ]
hub_genes$module <- names(hubs)
row.names(hub_genes) <- NULL
hub_genes <- hub_genes %>% select(module, everything())
write_csv(hub_genes, path = "./outputs/WGCNA-results/hub_genes.csv")
```
```{r sig_hubs}
sig_hubs <- hub_genes %>%
  filter(module %in% sigModules) %>%
  select(module, ID, Gene_Info) %>% 
  rename("hub gene" = ID, "UniProt best match" = Gene_Info) 
write_csv(sig_hubs, path = "./WGCNA-results/sig_hub_genes_table.csv")
write_excel_csv(sig_hubs, path = "./manuscript_figures/Table3.csv")
```
```{r datkME}
#this section is adapted from Rachel Wright's GitHub: https://github.com/rachelwright8/Ahya-White-Syndromes/
colnames(MEs1) <- MEmodule_colors
datKME <- signedKME(datExpr, MEs1, outputColumnName = "") %>% rownames_to_column(., "gene")
genecolors <- data.frame(gene = Genes, moduleColor = moduleColors)
genecolors_kME <- left_join(genecolors, datKME, by = "gene") 
###
```
```{r kME_files}
# Assemble input for WGCNA GO_MWU: dataframe with gene IDs and kME values for all genes within a module, 0 for all genes without
for (module in uniqModules){
modkME <- genecolors_kME %>% select(., "gene", "moduleColor", paste("kME", module, sep = ""))
colnames(modkME) <- c("gene", "moduleColor", "kME")
###
modkME$kME[modkME$moduleColor!=module] <- 0  #also need to change column names for color you pick above
#modkME$kME[modkME$moduleColor==module] <- 1 #leave commented out to keep kME values
modkME <- modkME %>% select(., -moduleColor)
# write csv
#write.csv(modkME, file = paste("./outputs/WGCNA-results/tables/", module,"_kme.csv",sep=""), quote=F, row.names=F)
write.csv(modkME, file = paste("./R/GO_MWU/", module,"_kme.txt",sep=""), quote=F, row.names=F)
#repeat for each module
}
```
### WGCNA Gene Ontology (GO) enrichment analysis
```{r module_GO_MWU}
# Run GO_MWU for any given module for Biological Process (BP) GO terms
commandArgs <- function(...) c("salmon_kme.txt", "BP")
source("./R/GO_MWU/GO_MWU_WGCNA.R")

# Run GO_MWU for Heat vs. control for Molecular Function GO terms
commandArgs <- function(...) c("brown_kme.txt", "MF")
source("./R/GO_MWU/GO_MWU_WGCNA.R")

# Run GO_MWU for Heat vs. control for Cellular Component (CC) GO terms
commandArgs <- function(...) c("salmon_kme.txt", "CC")
source("./R/GO_MWU/GO_MWU.R")
```
```{r module GO_MWU plot}
# Plot GO_MWU results
commandArgs <- function(...) c("salmon_kme.txt", "BP", "GO_MWU.salmon.png")
source("./R/GO_MWU/GO_MWU_WGCNA_plot.R")
commandArgs <- function(...) c("salmon_kme.txt", "MF", "GO_MWU.salmon.png")
source("./R/GO_MWU/GO_MWU_WGCNA_plot.R")
commandArgs <- function(...) c("salmon_kme.txt", "CC", "GO_MWU.salmon.png")
source("./R/GO_MWU/GO_MWU_WGCNA_plot.R")
```
```{r module_GO_MWU_loop}
#kMEfiles <- list.files(path = "./R/GO_MWU/", pattern = "_kme.txt")
###
intModules <- c("greenyellow", "brown", "lightcyan1", "darkgrey", "darkred", "midnightblue", "grey60", "darkorange", "skyblue", "paleturquoise", "violet", "orangered4")
for (module in intModules[c(12)]){
  print(module)
### command for GO_MWU analysis
  #input file name
tab <- paste(module, "_kme.txt", sep = "")
  commandArgs <- function(...) c(tab, "BP")
  source("./R/GO_MWU/GO_MWU_WGCNA.R")
}
```
```{r GO_MWU_figures}
module <- "orangered4"
#for (module in sigModules){
###
tab <- paste(module, "_kme.txt", sep = "")
fig <- as.character(paste("GO_MWU_", module, ".pdf", sep = ""))
levs <- c(0.05, 1e-10, 1e-15)
###
commandArgs <- function(...) c(tab, "BP", fig, module, 0.001, 1e-5, 1e-15, 1.0)
source("./R/GO_MWU/GO_MWU_WGCNA_plot.R")
#}
```
```{r modules_GO}
modules.GO <- as.list(
  c(greenyellow = "./R/GO_MWU/MWU_BP_greenyellow_kme.txt",
    brown = "./R/GO_MWU/MWU_BP_brown_kme.txt",
    lightcyan1 = "./R/GO_MWU/MWU_BP_lightcyan1_kme.txt",
    darkgrey = "./R/GO_MWU/MWU_BP_darkgrey_kme.txt",
    darkred = "./R/GO_MWU/MWU_BP_darkred_kme.txt",
    midnightblue = "./R/GO_MWU/MWU_BP_midnightblue_kme.txt",
    grey60 = "./R/GO_MWU/MWU_BP_grey60_kme.txt",
    darkorange = "./R/GO_MWU/MWU_BP_darkorange_kme.txt",
    skyblue = "./R/GO_MWU/MWU_BP_skyblue_kme.txt",
    paleturquoise = "./R/GO_MWU/MWU_BP_paleturquoise_kme.txt",
    violet = "./R/GO_MWU/MWU_BP_violet_kme.txt",
    orangered4 = "./R/GO_MWU/MWU_BP_orangered4_kme.txt")
  ) %>% map(read.table, header = T) %>%
  bind_rows(.id = "module") %>%
  as_tibble() %>%
  filter(p.adj < 0.05)

modules.GO %>%
  select(module, delta.rank, p.adj, name, nseqs, level, term) %>%
  arrange(module, p.adj) %>% 
  write_csv(path = "./outputs/WGCNA-results/GO_MWU/modules.GO.csv")

modules.GO %>%
  filter(p.adj < 0.05 & delta.rank >= 0) %>% 
  count(module)
```
###WGCNA EuKaryotic Orthologous Groups (KOG) enrichment analysis
```{r wgcna_kog}
# Create tibble to keep results of WGCNA module KOGMWU enrichment
modKOG <- tibble("module" = uniqModules)
modset <- uniqModules
for (i in 1:length(modset)) {
module <- modset[i]
modkME <- genecolors_kME %>% select(., gene, moduleColor, module)
colnames(modkME) <- c("gene", "moduleColor", "kME")
###
modkME$kME[modkME$moduleColor!=module] <- 0  #also need to change column names for color you pick above
# modkME$kME[modkME$moduleColor==module] <- 1 #leave commented out to keep kME values
modkME <- modkME %>% select(., -moduleColor)
modKOG$kME[i] <- list("kME" = modkME)
###
kogmwu_module <- kog.mwu(modkME, gene2kog) #%>% arrange("KOG_Class")
modKOG$KOG[i] <- list("KOG" = kogmwu_module)
#names(modKOGlist[i]) <- module
}
modKOG$KOG
```
```{r KOG_purrr}
modKOG <- modKOG %>% mutate(
         # If a KOG term has <10 genes associated with it, set delta rank to zero
         KOG = map(KOG, ~ mutate(., delta.rank = ifelse(nseqs < 10, 0, delta.rank))))

# Generate all KOG delta rank tables
modkogtables <- modKOG %>%
  unnest(KOG) %>%
  select(module, term, delta.rank) %>% 
  split(list(.$module), drop = TRUE) %>% 
  map(~ spread(., module, delta.rank)) %>% 
  map(~ column_to_rownames(., "term"))

# Generate KOG p-value stars
modkogpvals <- modKOG %>%
  unnest(KOG) %>%
  select(module, term, padj) %>%
  split(list(.$module), drop = TRUE) %>% 
  map(~ spread(., module, padj)) %>%
  map(~ column_to_rownames(., "term")) %>%
  map(~ transmute_all(., gtools::stars.pval))
```
```{r modKOG_heatmaps}
KOG_brown <- KOGheatmap(modkogtables$brown, modkogpvals$brown, main = "Brown", 
                      fontsize = 6)
ggsave(filename = "./outputs/WGCNA-results/KOGMWU/KOGheat.control.pdf", plot = KOG_brown, width = 80, height = 85, units = "mm", device = "pdf")

```
```{r modules_KOG_heatmap}
modkog_all <- bind_cols(modkogtables, modkogpvals)
modkog_all$term <- rownames(modkogtables)
write_csv(modkog_all, path = "./outputs/WGCNA-results/KOGMWU/kog_modules.csv")

modkogtable <- modKOG %>%
  unnest(KOG) %>%
  select(module, term, delta.rank) %>% 
  spread(module, delta.rank) %>%
  column_to_rownames("term")
  
modkogpadj <- modKOG %>%
  unnest(KOG) %>%
  select(module, term, padj) %>% 
  spread(module, padj) %>%
  column_to_rownames("term") %>%
  transmute_all(gtools::stars.pval)

KOG_modules <- KOGheatmap(modkogtable, modkogpadj,
  #labels_col = contrast_labs,
  #main = KOGtitle,
  fontsize = 8,
  fontsize_row = 7,
  fontsize_col = 8)

ggsave(filename = "./outputs/WGCNA-results/KOGMWU/KOG_modules_heatmap.pdf", KOG_modules, width = 200, height = 170, units = "mm")
```
```{r ComplexHeatmap_annotation}
# column annotation for treatments

# annotation to include module colors
module_annotation_col <- HeatmapAnnotation(modules = moddf$module_colors,
                                       col = list(modules = module_anno),
                                       which = "col",
                                       annotation_name_rot = 0,
                                       show_legend = FALSE
                                       )
# text matrix annotation for cell text
 cell_fun <- function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%.1f", t(modkogpadj)[i, j]), x, y, gp = gpar(fontsize = 6))
 }
```
```{r modKOG_ComplexHeatmap}
pdf(file = "./outputs/WGCNA-results/figures/ME_complexheatmap_KOG.pdf", width = 8, height = 6)
kog_heatmap <- Heatmap(modkogtable,
                      # col = col_fun_ge(modkogtable),
                      cell_fun = function(j, i, x, y, width, height, fill) {grid.text(sprintf("%s", modkogpadj[i, j]), x, y, gp = gpar(fontsize = 6))},
                      cluster_columns = hclustME,
                      top_annotation = module_annotation_col,
                      row_split = NULL,
                      border = FALSE,
                      rect_gp = gpar(col = "white", lwd = 1.5),
                      column_title_gp = gpar(fontsize = 8, fontface = "plain"),
                      row_order = rownames(modkogtable),
                      # column_names_rot = 0,
                      column_names_side = "top",
                      # column_names_centered = TRUE,
                      column_names_gp = gpar(fontsize = 8, fontface = "plain"),
                      # row_names_gp = gpar(fontsize = 8, fontface = "plain"),
                      # show_heatmap_legend = TRUE,
                      # heatmap_legend_param = list(title = "Eigengene treatment correlation",
                      #                             direction = "vertical",
                      #                             title_position = "leftcenter-rot",
                      #                             legend_height = unit(1.0, "in"),
                       height = unit(4, "in"),
                       width = unit(4, "in")
                      )
draw(kog_heatmap, column_title = "Module KOG enrichment heatmap", 
     show_annotation_legend = FALSE, heatmap_legend_side = "left"
     )
column_order(kog_heatmap)
```
```{r}
pdf("./outputs/WGCNA-results/figures/modules_KOGenrichment_heatmap.pdf", height = 8.5, width = 10)
kog_heatmap2 <- Heatmap(t(modkogtable),
                      # col = col_fun_delta(modkogtable),
                      cell_fun = function(j, i, x, y, width, height, fill) {grid.text(sprintf("%s", t(modkogpadj)[i, j]), x, y, gp = gpar(fontsize = 6))},
                      cluster_rows = hclustME,
                      right_annotation = module_barplot,
                      # row_split = NULL,
                      # border = FALSE,
                      # rect_gp = gpar(col = "white", lwd = 1.5),
                      # column_title_gp = gpar(fontsize = 8, fontface = "plain"),
                      column_order = rownames(modkogtable),
                      column_names_rot = 90,
                      column_names_side = "bottom",
                      # column_names_centered = TRUE,
                      column_names_gp = gpar(fontsize = 8, fontface = "plain"),
                      # row_names_gp = gpar(fontsize = 8, fontface = "plain"),
                      # show_heatmap_legend = TRUE,
                      heatmap_legend_param = list(title = "KOG enrichment delta-rank",
                                                  direction = "vertical",
                                                  title_position = "leftcenter-rot",
                                                  legend_height = unit(1.0, "in"),
                       height = unit(4, "in"),
                       width = unit(4, "in")
                      ))
draw(kog_heatmap2, column_title = "Module KOG enrichment heatmap", 
     show_annotation_legend = FALSE, heatmap_legend_side = "left"
     )
```
```{r}
pdf("./outputs/WGCNA-results/modules_correlations_KOGenrichment_heatmap.pdf", height = 8, width = 12)
combmap <- me_heatmap + kog_heatmap2
draw(combmap,  show_annotation_legend = FALSE, heatmap_legend_side = "left")
```

### Module trait gene significance (GS) versus interconnectivity (kME) scatterplots, scaled gene profile plots and edge files
```{r}
# calculate gene trait significance for each treatment, genotype, etc.
geneTraitSignificance <- as.data.frame(cor(datExpr, datTraits, use = "p")) 
# pivot longer
traitGS <- geneTraitSignificance %>% 
  rownames_to_column("ID")# %>% 
  # pivot_longer(cols = control:Antibiotics.Heat, names_to = "Treatment.GS", values_to = "GS")
# 
# what is different about module membership and kME statistics?
# calculate gene module membership, defined as correlation of each gene against the module eigengene expression
geneModuleMembership <- as.data.frame(cor(datExpr, MEs1, use = "p"))
```
```{r df_kME_GS}
MM <- geneModuleMembership
colnames(MM) <- module_colors
MMlong <- MM %>% 
  rownames_to_column("ID") %>% 
  pivot_longer(cols = -ID, names_to = "module.MM", values_to = "MM")

longKME <- datKME %>% 
  rename(gene = "ID") %>% 
  pivot_longer(cols= -ID, names_to = "module", values_to = "kME")

df_gene_GS_kME <- genecolors %>%
  rename(gene = "ID") %>% 
  full_join(traitGS, by = "ID") %>% 
  full_join(longKME, by = "ID") %>%
  filter(moduleColor == module) %>% 
  select(-module)
```
```{r module_GS_kME_results_tables}
# write output tables with gene kME statistics and trait gene significance for each module
 for (module in sigModules) {
#datKME <- datKME %>% column_to_rownames("gene")
df_mod_GS_kME <- df_gene_GS_kME %>%
  filter(moduleColor == module) %>% 
  select(-moduleColor) %>% 
  select(ID, kME, everything()) %>% 
  arrange(desc(kME)) %>% 
  left_join(., gene_annotation, by = "ID")
write_csv(df_mod_GS_kME, path = paste("./outputs/WGCNA-results/tables/", module, "_GS_kME.csv", sep = ""))
}
```
```{r}
GS <- as.numeric(cor(datExpr, datTraits, use = "p"))
GScolor <- numbers2colors(GS, signed = T)
numberOfColumn <- colnames(datKME[-1])
```

Fix using large data frame created above, try to facet scatterplots according to treatment trait of interest
```{r kme_scatterplots}
module <- "darkorange"
# pdf("./outputs/WGCNA-results/figures/module_kME_scatterplots.pdf")
# for (module in sigModules) {
  column <- match(module, numberOfColumn)     
  inModule <- (moduleColors == module)
  
# write output tables with gene kME statistics and trait gene significance for each module
#datKME <- datKME %>% column_to_rownames("gene")
datKME.GS <- data.frame(cbind(datKME[inModule, column], GS[inModule]))
colnames(datKME.GS) <- c("kME", "GS")
datKME.GS$ID <- Genes[inModule]
hikME <- datKME.GS %>%
  arrange(desc(kME)) %>% 
  left_join(., gene_annotation, by = "ID")
#write_csv(hikME, path = paste("./outputs/WGCNA-results/tables/", module, "_kME.csv", sep = ""))

coef <- coef(lm(GS ~ kME, data = hikME))
g <- hikME %>% ggplot(., aes(GS, kME)) +
  geom_point(color = module, size = 2, alpha = 0.2) + 
  geom_abline(slope = coef[1], intercept = coef[2], color = module) +
  xlab(paste("Module membership ", module, "module")) + 
  ylab(paste("Gene Significance", "Control")) +
  ggtitle(paste("kME.", module, "vs. GS")) + 
  xlim(-0.5, 1) +
  ylim(-0,1.0) +
  theme_bw() +
  geom_text_repel(data = hikME[1:10, ], aes(label = hikME[1:10, ]$Gene_Info), color = "black", size = 2.5, box.padding = unit(0.35, "lines"))
print (g)
# }
dev.off()
```

### Module eigengene and gene-scaled profile plots
```{r}
#gather what we know about the genes
geneInfo<-data.frame(row.names = colnames(datExpr), module = moduleColors, membership = NA)
for(gene in rownames(geneInfo)){
	currentmod <- geneInfo[gene, 'module']
	geneInfo[gene, 'membership'] <- geneModuleMembership[gene, paste('ME', currentmod, sep='')]
}
geneInfo <- geneInfo[order(geneInfo$module, geneInfo$membership, decreasing=T), ]
#genematch <- match(rownames(geneInfo), genefeatures$ID)
#geneInfo$Info <- genefeatures$GeneInfo[genematch]
```
```{r}
#plot eigengenes along with highly correlated individual genes
pdf(file = "./outputs/WGCNA-results/figures/ModuleProfiles.pdf", width = 4.5, height = 3.5)

#initialize plot with eigengene -- we scale the expression value to mean=0 sd=1 so we can compare profiles of genes with different absolute expression levels
colnames(MEs1) <- module_colors
for (module in intModules){
MEagg <- aggregate(scale(MEs1[,module])~Treatment+Colony, FUN = mean, data = samples) %>% arrange(Treatment)
MEagg$TC <- paste(MEagg$Colony, MEagg$Treatment, sep=".")
plot(MEagg$V1, ylim = c(-2,2), type = "l", lwd = 3, col = "black", ylab = "Scaled Expression", xlab = NULL, main = gsub("ME","M",module))
abline(h = 0, lty = 2, lwd = 0.1)
#plot each individual gene with high membership on top of the eigengene
for(gene in rownames(geneInfo)[geneInfo$module==module & geneInfo$membership > 0.8]){
	agg <- aggregate(scale(datExpr[,gene])~Treatment+Colony, FUN = mean, data = samples) %>% arrange(Treatment)
	lines(agg$V1, type = "l", lwd = 0.1, col=module)
}
# replot eigengenes on top of the individual gene expression profiles
lines(MEagg$V1, type = "l", lwd = 5,col=module)
}
```
### VisANT Network edge files export
```{r visant_edge_file}
for (module in intModules)
{
inModule <- (moduleColors == module)
# Select the genes within each module and extract gene info
modGeneIDs <- Genes[inModule]
# Select the highly connected genes 
conmodGeneIDs <- rownames(geneInfo)[geneInfo$module == module & geneInfo$membership > 0.75]
modGeneNames <-gene_annotation[modGeneIDs, 2]
conmodGeneNames <-gene_annotation[conmodGeneIDs, 2]
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule]
dimnames(modTOM) = list(modGeneIDs, modGeneIDs)
# Export the network into an edge list file VisANT can read
vis = exportNetworkToVisANT(modTOM[conmodGeneIDs,conmodGeneIDs],
file = paste("./outputs/WGCNA-results/lists/", "VisANTInput-con-", gsub("E", "", module), ".txt", sep=""),
weighted = TRUE,
threshold = 0,
probeToGene = data.frame(conmodGeneIDs, conmodGeneNames))
}
```

### WGCNA module gene expression heatmaps
```{r}
### Create differentially expressed gene matrix 
#Create heatmap matrix and annotation groupings
pdf(file = "./outputs/WGCNA-results/figures/darkorange_heatmap.pdf", height = 14, width = 11)
module <- "darkorange"
#for(module in sigModules) {
inModule <- (moduleColors == module)
mat_module  <- assay(vsd)[inModule, ]
#
mat_module <- mat_module - rowMeans(mat_module)
heatmap_module <- Heatmap(mat_module,
        #row_order = rownames(mat_ld1),
        col = col_fun_ge(mat_module),
        top_annotation = sample_annotation,
        row_dend_width = unit(1.5, "in"),
        row_labels = as.character(gene_annotation[rownames(mat_module), 3]),
        show_heatmap_legend = TRUE,
        heatmap_legend_param = list(title = "Normalized gene expression",
                 just = c(0, 0),
                 direction = "vertical",
                 title_position = "leftcenter-rot",
                 legend_height = unit(1, "in")),
        row_names_gp = gpar(fontsize = 6, fontface = "plain"),
        column_names_gp = gpar(fontsize = 0, fontface = "plain"),
        height = unit(13, "in"),
        width = unit(4, "in"))
draw(heatmap_module, heatmap_legend_side = "left", legend_title_gp = gpar(fontsize = 10, fontface = "plain"), padding = unit(c(0.5, -2.0, 0.5, 0.5), "in"))
#}
```

### WGCNA module GO term gene expression heatmaps
```{r}
# Run go_plotresults
commandArgs <- function(...) c("lightcyan1_kme.txt", "BP")
source("./R/GO_MWU/go_plotresults_WGCNA.R")

```
### GO Term module eigengenes
```{r}
# ribosome
# immune defense
# ion transport
# apoptosis/programmed cell death
```



## Trans-kingdom network analysis 
```{r dat_phyla}
glom_phylum <- tax_glom(ps.AXH.rel, taxrank = "Phylum")
ps.AXH_phylum <- psmelt(glom_phylum)
#ps.AXH_phylum <- filter(ps.AXH_phylum, Abundance > 0)
ps.AXH_phylum$Phylum <- as.character(ps.AXH_phylum$Phylum)
ps.AXH_phylum$Kingdom <- gsub("D_0__", "", ps.AXH_phylum$Kingdom)
ps.AXH_phylum$Phylum <- gsub("D_1__", "", ps.AXH_phylum$Phylum)
#ps.AXH_phylum$Phylum[ps.AXH_phylum$Abundance < 0.01] <- "<1% abundance"
### create properly formatted table
datPhyla <- ps.AXH_phylum %>% select(Phylum, Sample, Abundance) %>%
  tidyr::pivot_wider(names_from = Phylum, values_from = Abundance) %>% 
  arrange(Sample) %>%
  filter(Sample!='Hw2.6a')
rownames(datPhyla) <- gsub('.', '-', datPhyla$Sample, fixed = TRUE)
datPhyla <- datPhyla[-1]
row.names(datPhyla) <- rownames(datTraits)
```
```{r ME_correlations_phyla}
modulePhylaCor <- cor(MEs1, datPhyla, use = "p")
modulePhylaPvalue <- corPvalueStudent(modulePhylaCor, nSamples)
modulePhylaCors <- as.data.frame(modulePhylaCor, modulePhylaPvalue)
```
```{r ME_correlations_alpha}
datAlpha <- ps.AXH_richness %>% filter(ID!='Hw2.6a')
moduleAlphaCor <- cor(MEs1, datAlpha, use = "p")
moduleAlphaPvalue <- corPvalueStudent(moduleAlphaCor, nSamples)
moduleAlphaCors <- as.data.frame(moduleAlphaCor, moduleAlphaPvalue)
```
```{r ME_phyla_heatmap}
# Will display correlations and their p-values
#textMatrix <- paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 2), ")", sep = "")
# Only displays significant correlations p < 0.05
textMatrix <- character()
for (i in 1:length(modulePhylaPvalue)){
  if(modulePhylaPvalue[i] < 0.05){ text <-  paste(signif(modulePhylaCor[i], 2), "\n(", signif(modulePhylaPvalue[i], 2), ")", sep = "") } else { text <- "" }
  textMatrix[i] <- text
}
dim(textMatrix) <- dim(modulePhylaCor)
#par(mar = c(10, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
pdf(file = "./outputs/WGCNA-results/figures/ME_phyla_heatmap.pdf", width = 11, height = 8.5)
labeledHeatmap(Matrix = modulePhylaCor,
               colors = geneexpcolors2,
               textMatrix = textMatrix,
               xLabels = names(datPhyla),
               xLabelsPosition = "bottom",
               xLabelsAngle = 345,
               xLabelsAdj = 0,
               yLabels = names(MEs1),
               ySymbols = gsub("ME", "", names(MEs1)),
               yLabelsPosition = "left",
               yColorWidth = 0.01,
               x.adj.lab.y = 1,
               #verticalSeparator.x = names(moduleTraitCor),
               verticalSeparator.interval = 1,
               verticalSeparator.col = "white",
               verticalSeparator.lwd = 3,
               horizontalSeparator.interval = 1,
               horizontalSeparator.col = "white",
               horizontalSeparator.lwd = 3,
               colorLabels = FALSE,
               setStdMargins = TRUE,
               margins = c(2,2),
               plotLegend = TRUE,
               cex.text = 0.4,
               cex.lab.x = 0.9,
               zlim = c(-1,1),
main = paste("Module-Phyla correlations"),
xlab = "Bacterial Phyla (decreasing relative abundance -->)")
```
```{r phyla_ComplexHeatmap_annotation}
# column annotation for treatments

# annotation to include module colors
moddf <- data.frame(module_colors)
module_anno  <- module_colors
names(module_anno) <- module_colors
module_sizes <- data.frame(table(moduleColors)) %>% filter(moduleColors != "grey") %>% arrange(desc(Freq))
colnames(module_sizes) <- c("module_colors", "module_size")
moddf <- left_join(moddf, module_sizes, by = "module_colors")
module_annotation <- HeatmapAnnotation(modules = moddf$module_colors,
                                       col = list(modules = module_anno),
                                       which = "row",
                                       annotation_name_rot = 0,
                                       show_legend = FALSE
                                       )
# text matrix annotation for cell text
 cell_fun <- function(j, i, x, y, width, height, fill) {
        grid.text(sprintf("%.1f", textMatrix[i, j]), x, y, gp = gpar(fontsize = 10))
 }
# barplot annotation of module sizes
module_barplot <- HeatmapAnnotation(module_size = anno_barplot(moddf$module_size,
                                                  gp = gpar(fill = as.character(moddf$module_colors))),#module_sizes$moduleColors)),
                                    which = "row",
                                    show_legend = FALSE,
                                    width = unit(1.5, "in")
                                    )
```
```{r ME_phyla_heatmap_ComplexHeatmap}
pdf(file = "./outputs/WGCNA-results/figures/ME_complexheatmap_phyla.pdf", width = 10, height = 8)
me_heatmap <- Heatmap(modulePhylaCor,
                      col = col_fun_cor,
                      cell_fun = function(j, i, x, y, width, height, fill) {grid.text(sprintf("%s", textMatrix[i, j]), x, y, gp = gpar(fontsize = 6))},
                      cluster_rows = hclustME,
                      #top_annotation = treatment_annotation,
                      left_annotation = module_annotation,
                      right_annotation = module_barplot,
                      row_split = NULL,
                      border = FALSE,
                      rect_gp = gpar(col = "white", lwd = 3),
                      column_title_gp = gpar(fontsize = 12, fontface = "plain"),
                      column_order = colnames(datPhyla),
                      column_names_rot = 60,
                      column_names_side = "bottom",
                      column_names_centered = FALSE,
                      column_names_gp = gpar(fontsize = 12, fontface = "plain"),
                      row_dend_width = unit(1.5, "in"),
                      show_heatmap_legend = TRUE,
                      heatmap_legend_param = list(title = "Eigengene treatment correlation",
                                                  direction = "vertical",
                                                  title_position = "leftcenter-rot",
                                                  legend_height = unit(3, "in"),
                      height = unit(7, "in"),
                      width = unit(4, "in"))
                      )
draw(me_heatmap, column_title = "Module eigengene bacteria phylum correlation heatmap", 
     show_annotation_legend = FALSE, heatmap_legend_side = "left"
     )
```
I would also like to...
...add treatment color annotation to top of heatmap...and fix legend label position (modules, Treatment, module_size)
...adjust legend position...
...add heatmap to show module eigengene correlations to bacteria taxa...alpha diversity, beta diversity, etc.
...include text cloud annotation based on GO enrichment...


```{r ME_transkingdom_ComplexHeatmap}

```

## Genotype consensus network
```{r}
datExpr_HW1 <- as.data.frame(countdata_vst) %>% select(contains("Hw1")) %>% t()
datExpr_HW2 <- as.data.frame(countdata_vst) %>% select(contains("Hw2")) %>% t()
datExpr_WT1 <- as.data.frame(countdata_vst) %>% select(contains("Wt1")) %>% t()
datExpr_WT2 <- as.data.frame(countdata_vst) %>% select(contains("Wt2")) %>% t()
```
Setup multi-set structure for genotype consensus module detection
```{r multi-set}
nSets <- 4
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels <- c(unique(samples$Colony))
shortLabels <- setLabels
# Form multi-set expression data
multiExpr <- vector(mode = "list", length = nSets)
multiExpr[[1]] <- list(data = datExpr_HW1)
multiExpr[[2]] <- list(data = datExpr_HW2)
multiExpr[[3]] <- list(data = datExpr_WT1)
multiExpr[[4]] <- list(data = datExpr_WT2)
# Check that the data has the correct format for many functions operating on multiple sets:
exprSize <- checkSets(multiExpr)
exprSize
```
```{r multi-set_check}
# Check that all genes and samples have sufficiently low numbers of missing values.
gsg <- goodSamplesGenesMS(multiExpr, verbose = 3)
gsg$allOK
# Correct problems
if (!gsg$allOK)
{
# Print information about the removed genes:
if (sum(!gsg$goodGenes) > 0)
printFlush(paste("Removing genes:", paste(names(multiExpr[[1]]$data)[!gsg$goodGenes],
collapse = ", ")))
for (set in 1:exprSize$nSets)
{
2
if (sum(!gsg$goodSamples[[set]]))
printFlush(paste("In set", setLabels[set], "removing samples",
paste(rownames(multiExpr[[set]]$data)[!gsg$goodSamples[[set]]], collapse = ", ")))
# Remove the offending genes and samples
multiExpr[[set]]$data = multiExpr[[set]]$data[gsg$goodSamples[[set]], gsg$goodGenes];
}
# Update exprSize
exprSize <- checkSets(multiExpr)
}
```
```{r}
sampleTrees = list()
for (set in 1:nSets)
{
sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}
```
```{r}
for (set in 1:nSets)
plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
xlab="", sub="", cex = 0.7);
```

```{r WGCNA_consensus_network}
netcons <- blockwiseConsensusModules(
multiExpr,
power = 6,
minModuleSize = 30,
deepSplit = 2,
pamRespectsDendro = FALSE,
mergeCutHeight = 0.25,
numericLabels = TRUE,
minKMEtoStay = 0,
saveTOMs = FALSE,
verbose = 5
)
```
## Genotype-specific WGCNA networks
```{r}
# Gather vst-transformed counts into tibble
colcounts_vst <- as.data.frame(countdata_vst) %>%
  rownames_to_column("gene") %>%
  as_tibble(.) %>%
  gather(key = "SampleID", value = "count", -gene)
# Join vst counts with sample data
coldata_net <- samples #%>%
  #select("SampleID", "Colony")
allvst <- left_join(samples, colcounts_vst, by = "SampleID") 
```
```{r}
# Group vst counts by Colony
NET <- allvst %>% 
  group_by(Colony) %>%
  nest()
# Create nested dataframe with sample data, sample traits, and datExpr matrix
NET <- NET %>%
  mutate(sdat = map(.x = data, ~ data.frame(column_to_rownames(distinct(., SampleID, Treatment, Batch), "SampleID"))),
         datTraits = map(.x = data, ~ data.frame(column_to_rownames(distinct(., SampleID, control, Heat, Antibiotics, Antibiotics.Heat), "SampleID"))),
         datExpr = map(.x = data, ~ pivot_wider(select(., SampleID, gene, count), names_from = SampleID, values_from = count)),
         datExpr = map(.x = datExpr, ~ t(column_to_rownames(., "gene")))
         )
```
```{r}
# Find correlation power R^N that satisfies scale free critereon (SFT.R.sq>0.9) for each colony
NET <- NET %>%
  mutate(sft = map(.x = datExpr, ~ pickSoftThreshold(., verbose = 5)))
```
```{r}
NET <- NET %>%
  mutate(net = map(.x = datExpr, ~ blockwiseModules(., 
                                                    weights=NULL, 
                                                    corType = "bicor",
                                                    power = 9,
                                                    networkType = "signed",
                                                    maxBlockSize = 27000,
                                                    deepSplit = 2,
                                                    detectCutHeight = 0.99,
                                                    minModuleSize = min(50, ncol(datExpr)/2 ),
                                                    mergeCutHeight = 0.3,
                                                    TOMType = "signed",
                                                    saveTOMs = FALSE,
                                                    numericLabels=T, 
                                                    checkMissingData = TRUE, verbose=5)))
```



## Mike's old approach
### Select which treatments to use in DESeq object construction
anti: Control-Antibiotics
heat: Control-Heat
anti.heat: Control-Antibiotics.Heat
antixheat: Control-Antibiotics-Heat-Antibiotics.Heat
```{r}
countdata_anti <- dplyr::select(countdata.sorted, matches("[HW][wt][12].[56]."))
countdata_heat <- dplyr::select(countdata.sorted, matches("[HW][wt][12].[46]."))
countdata_anti.heat <- dplyr::select(countdata.sorted, matches("[HW][wt][12].[16]."))
###
countdata_antixheat <- dplyr::select(countdata.sorted, matches("[HW][wt][12].[1456]."))
```
```{r}
countdata_HW1 <- dplyr::select(countdata_antixheat, matches("Hw1.*"))
countdata_HW2 <- dplyr::select(countdata_antixheat, matches("Hw2.*"))
countdata_WT1 <- dplyr::select(countdata_antixheat, matches("Wt1.*"))
countdata_WT2 <- dplyr::select(countdata_antixheat, matches("Wt2.*"))
```

```{r}
samples_anti <- filter(samples, Treatment == "control" | Treatment == "Antibiotics")
samples_heat <- filter(samples, Treatment == "control" | Treatment == "Heat")
###
samples_anti.heat <- filter(samples, Treatment == "control" | Treatment == "Antibiotics.Heat")
###
samples_antixheat <- filter(samples, Treatment == "control" | Treatment == "Antibiotics" | Treatment == "Heat" | Treatment == "Antibiotics.Heat")
```
```{r}
samples_HW1 <- filter(samples_antixheat, Colony == "HW1")# %>% select(-contains("W"), -contains("2"))
samples_HW2 <- filter(samples_antixheat, Colony == "HW2")# %>% select(-contains("W"), -contains("1"))
samples_WT1 <- filter(samples_antixheat, Colony == "WT1")# %>% select(-contains("H"), -contains("2"))
samples_WT2 <- filter(samples_antixheat, Colony == "WT2")# %>% select(-contains("H"), -contains("1"))
```
### Convert to matrices 
```{r, include=FALSE}
      countdata_anti <- as.matrix(countdata_anti)
      countdata_heat <- as.matrix(countdata_heat)
      countdata_anti.heat <- as.matrix(countdata_anti.heat)
      countdata_antixheat <- as.matrix(countdata_antixheat)
```
```{r, include=FALSE}
      countdata_HW1 <- as.matrix(countdata_HW1)
      countdata_HW2 <- as.matrix(countdata_HW2)
      countdata_WT1 <- as.matrix(countdata_WT1)
      countdata_WT2 <- as.matrix(countdata_WT2)
```



### Create DESeq data objects
### DESeq2 treatment model objects
```{r, message=FALSE}
      dds_anti <- DESeqDataSetFromMatrix(countData=countdata_anti, colData=samples_anti, design= ~Batch + Colony + Treatment)
      dds_anti$Treatment <- factor(dds_anti$Treatment, levels=c("control", "Antibiotics"))
relevel(dds_anti$Treatment, ref = "control")
```
```{r, message=FALSE}
      dds_heat <- DESeqDataSetFromMatrix(countData=countdata_heat, colData=samples_heat, design= ~Batch + Colony + Treatment)
      dds_heat$Treatment <- factor(dds_heat$Treatment, levels=c("control", "Heat"))
relevel(dds_heat$Treatment, ref = "control")
```
```{r, message=FALSE}
      dds_anti.heat <- DESeqDataSetFromMatrix(countData=countdata_anti.heat, colData=samples_anti.heat, design= ~Batch + Colony + Treatment)
      dds_anti.heat$Treatment <- factor(dds_anti.heat$Treatment, levels=c("control", "Antibiotics.Heat"))
relevel(dds_anti.heat$Treatment, ref = "control")
```
```{r, message=FALSE}
      dds_antixheat <- DESeqDataSetFromMatrix(countData=countdata_antixheat, colData=samples_antixheat, design= ~Batch + Colony + Treatment)
      dds_antixheat$Treatment <- factor(dds_antixheat$Treatment, levels=c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
relevel(dds_antixheat$Treatment, ref = "control")
```
### DESeq2 genotype model objects
```{r, message=FALSE}
      dds_HW1 <- DESeqDataSetFromMatrix(countData=countdata_HW1, colData=samples_HW1, design= ~Treatment)
### Batch effect encompasses Treatment
      dds_HW1$Treatment <- factor(dds_HW1$Treatment, levels=c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
relevel(dds_HW1$Treatment, ref = "control")
```
```{r, message=FALSE}
      dds_HW2 <- DESeqDataSetFromMatrix(countData=countdata_HW2, colData=samples_HW2, design= ~Batch + Treatment)
      dds_HW2$Treatment <- factor(dds_HW2$Treatment, levels=c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
relevel(dds_HW2$Treatment, ref = "control")
```
```{r, message=FALSE}
      dds_WT1 <- DESeqDataSetFromMatrix(countData=countdata_WT1, colData=samples_WT1, design= ~Batch + Treatment)
      dds_WT1$Treatment <- factor(dds_WT1$Treatment, levels=c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
relevel(dds_WT1$Treatment, ref = "control")
```
```{r, message=FALSE}
      dds_WT2 <- DESeqDataSetFromMatrix(countData=countdata_WT2, colData=samples_WT2, design= ~Batch + Treatment)
      dds_WT2$Treatment <- factor(dds_WT2$Treatment, levels=c("control", "Antibiotics", "Heat", "Antibiotics.Heat"))
relevel(dds_WT2$Treatment, ref = "control")
```
### Check annotation and dds object rowname order coherence
```{r}
all(rownames(dds_anti) == rownames(gene_annotation))
all(rownames(dds_heat) == rownames(gene_annotation))
all(rownames(dds_anti.heat) == rownames(gene_annotation))
all(rownames(dds_antixheat) == rownames(gene_annotation))
```
```{r}
all(rownames(dds_HW1) == rownames(gene_annotation))
all(rownames(dds_HW2) == rownames(gene_annotation))
all(rownames(dds_WT1) == rownames(gene_annotation))
all(rownames(dds_WT2) == rownames(gene_annotation))
```

### Add gene feature annotation to DESeqDataSets
```{r}
mcols(dds_anti) <- cbind(mcols(dds_anti), gene_annotation)
mcols(dds_heat) <- cbind(mcols(dds_heat), gene_annotation)
mcols(dds_anti.heat) <- cbind(mcols(dds_anti.heat), gene_annotation)
mcols(dds_antixheat) <- cbind(mcols(dds_antixheat), gene_annotation)
```
```{r}
mcols(dds_HW1) <- cbind(mcols(dds_HW1), gene_annotation)
mcols(dds_HW2) <- cbind(mcols(dds_HW2), gene_annotation)
mcols(dds_WT1) <- cbind(mcols(dds_WT1), gene_annotation)
mcols(dds_WT2) <- cbind(mcols(dds_WT2), gene_annotation)
```

### Perform DESeq2 analyses
```{r, message=FALSE}
      dds_anti <- DESeq(dds_anti)
      dds_heat <- DESeq(dds_heat)
      dds_anti.heat <- DESeq(dds_anti.heat)
      dds_antixheat <- DESeq(dds_antixheat)
```
```{r, message=FALSE}
      dds_HW1 <- DESeq(dds_HW1)
      dds_HW2 <- DESeq(dds_HW2)
      dds_WT1 <- DESeq(dds_WT1)
      dds_WT2 <- DESeq(dds_WT2)
```

### Filter low counts
```{r}
      keep <- rowSums(counts(dds_antixheat), na.rm = TRUE) >= 10
      dds_anti <- dds_anti[keep,]
      dds_heat <- dds_heat[keep,]
      dds_anti.heat <- dds_anti.heat[keep,]
      dds_antixheat <- dds_antixheat[keep,]
```
```{r}
      dds_HW1 <- dds_HW1[keep,]
      dds_HW2 <- dds_HW2[keep,]
      dds_WT1 <- dds_WT1[keep,]
      dds_WT2 <- dds_WT2[keep,]
```

### Obtain DESeq results
```{r}
      res_anti <- results(dds_anti)
      res_heat <- results(dds_heat)
      res_anti.heat <- results(dds_anti.heat)
      res_antixheat <- results(dds_antixheat)
```
```{r}
      res_HW1 <- results(dds_HW1)
      res_HW2 <- results(dds_HW2)
      res_WT1 <- results(dds_WT1)
      res_WT2 <- results(dds_WT2)
```

### Check output of Antibiotics DESeq2 analysis to ensure quality
```{r}
resultsNames(dds_anti)
summary(res_anti)
```
```{r}
res_anti$IDGeneInfo <- mcols(dds_anti)$IDGeneInfo
res_anti$IDGeneInfo <- as.character(res_anti$IDGeneInfo)
```
```{r}
plotDispEsts(dds_anti)
plotMA(res_anti, ylim = c(-20, 20))
```

### Check output of Heat DESeq2 analysis to ensure quality
```{r}
resultsNames(dds_heat)
summary(res_heat)
```

```{r}
res_heat$ID <- mcols(dds_heat)$ID

res_heat$ID <- as.character(res_heat$ID)
```
```{r}
plotDispEsts(dds_heat)
plotMA(res_heat, ylim = c(-20, 20))
```

### Check output of Antibiotics.Heat DESeq2 analysis to ensure quality
```{r}
resultsNames(dds_anti.heat)
summary(res_anti.heat)
```
```{r}
res_anti.heat$IDGeneInfo <- mcols(dds_anti.heat)$IDGeneInfo
res_anti.heat$IDGeneInfo <- as.character(res_anti.heat$IDGeneInfo)
```
```{r}
plotDispEsts(dds_anti.heat)
plotMA(res_anti.heat, ylim = c(-20, 20))
```

### Check output of AntibioticsXHeat DESeq2 analysis to ensure quality
```{r}
resultsNames(dds_antixheat)
summary(res_antixheat)
```
```{r}
res_antixheat$IDGeneInfo <- mcols(dds_antixheat)$IDGeneInfo
res_antixheat$IDGeneInfo <- as.character(res_antixheat$IDGeneInfo)
```
```{r}
plotDispEsts(dds_antixheat)
plotMA(res_antixheat, ylim = c(-20, 20))
```

## Manuscript figures, panels, and supplementary figures
```{r}
ggsave(plot = KOG_heat.control, filename = "./manuscript_figures/FigS##_KOG_heat.control.pdf", width = 112, height = 85, units = "mm", device = "pdf")
ggsave(plot = KOG_anti.control, filename = "./manuscript_figures/FigS##_KOG_anti.control.pdf", width = 112, height = 85, units = "mm", device = "pdf")
ggsave(plot = KOG_anti.heat.control, filename = "./manuscript_figures/FigS##_KOG_anti.heat.control.pdf", width = 112, height = 85, units = "mm", device = "pdf")
```

```{r}
# Plot GO_MWU results for BP treatment contrasts
commandArgs <- function(...) c("heat.control.logP.txt", "BP", "GO_MWU.heat.control.pdf", 1e-4, 1e-5, 1e-6, 1)
source("./R/GO_MWU/GO_MWU_plot.R")

commandArgs <- function(...) c("anti.control.logP.txt", "BP", "GO_MWU.anti.control.pdf", 1e-4, 1e-5, 1e-6, 1)
source("./R/GO_MWU/GO_MWU_plot.R")

commandArgs <- function(...) c("anti.heat.control.logP.txt", "BP", "GO_MWU.heat.control.pdf", 1e-4, 1e-5, 1e-6, 1)
source("./R/GO_MWU/GO_MWU_plot.R")
```
## clusterProfiler
```{r}
library("clusterProfiler")
```
